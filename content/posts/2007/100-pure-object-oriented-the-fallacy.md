---
title: "100% pure Object-Oriented: The Fallacy"
date: "2007-09-04T19:22:00.000Z"
tags: ["career", "paradigms"]
years: "2007"
---

<p></p>
<div style="float: right;"><img src="http://s3.amazonaws.com/akitaonrails/assets/2007/9/4/ptr0121l.jpg" srcset="http://s3.amazonaws.com/akitaonrails/assets/2007/9/4/ptr0121l.jpg 2x" alt=""></div>
<p>Essa é uma das afirmações mais falaciosas quando queremos criar uma Guerra Religiosa: <em>“Sua linguagem não é 100% orientada-a-objetos, portanto, logo, por conseguinte, a minha é mais forte.”</em> Quantas vezes já não ouvimos isso? Acho que desde que Simula (a primeira orientada a objetos) ou C with Classes (a primeira extenção de classes para C) foram lançados, décadas atrás, ouvimos a mesma coisa.</p>
<p>Ela parte de dois princípios argumentativos igualmente falaciosos:</p>
<ol>
  <li><em>“Toda boa linguagem é orientada a objetos.”</em></li>
  <li><em>“A quantidade de funcionalidades OO que uma linguagem suporta é diretamente proporcial à sua capacidade.”</em></li>
</ol>
<p></p>
<p></p>
<p>A primeira não pode ser considerada um axioma, porque possui muitos falsos positivos. A segunda é derivada da primeira e não podemos <a href="https://en.wikipedia.org/wiki/Negative_proof">provar uma negativa</a> baseada em outra negativa. Foi o que eu expliquei no artigo <a href="https://www.akitaonrails.com/2007/8/23/off-topic-inimigos-da-razo">Inimigos da Razão</a>. Aliás, nenhum dos criadores de linguagens costuma usar esse tipo de afirmação.</p>
<p>Basta lembrar que orientação a objetos é apenas <strong>uma</strong> de dezenas de características que moldam uma linguagem e nenhuma implementa 100% delas (porque não seria prático). No <a href="https://en.wikipedia.org/wiki/Categorical_list_of_programming_languages">wikipedia</a> há mais detalhes mas só como exemplos. Temos linguagens orientadas a aspectos (Java, Common Lisp), linguagens compiláveis (Ada, Algol, C), linguagens concorrentes – que enviam mensagens (Concurrent Pascal, Clik, E, Erlang), linguagens orientadas a dados (<span class="caps">SQL</span>, <span class="caps">ABAP</span>, Clipper), linguagens declarativas (Prolog), linguagens funcionais (Lisp, F#). E por aí vai. Isso sem contar as que tem tipagem forte/fraca ou estática/dinâmica.</p>
<p>12 anos atrás houve muita discussão se Java é ou não 100% orientada a objetos. O problema: não existe uma definição oficial para isso. Não existe um paper na <span class="caps">ISO</span>, no <span class="caps">ECMA</span>, nenhuma <span class="caps">RFC</span>, <span class="caps">IEEE</span> ou qualquer coisa que categoricamente defina <em>“isto <strong>é</strong>, sem sombra de dúvida 100% O.O., ou 50% O.O.”</em>. O que se considera – por consenso público – uma linguagem O.O?</p>
<ul>
  <li>suporte encapsulamento</li>
  <li>suporte herança</li>
  <li>suporte polimorfismo</li>
  <li>faça chamadas através do envio de mensagens entre objetos</li>
  <li>todos os tipos básicos são objetos</li>
</ul>
<p><a href="https://forum.java.sun.com/thread.jspa?threadID=754518&amp;tstart=466">Alguns</a> <a href="https://forum.java.sun.com/thread.jspa?threadID=5120371&amp;messageID=9418761">dirão</a> que Java suporta herança simples, mas como não suporta herança múltipla, não é O.O. C++ suporta múltipla herança. Outros vão contra-argumentar que de fato Java suporta múltipla-herança de interfaces. Alguns dirão que Java tem tipos primitivos e isso não é O.O. C++ também tem, portanto também não é O.O. Outros vão atacar dizendo que só deveria haver tipos básicos como objetos. Ou seja, tipos primitivos com a ‘gambiarra’ de classes Wrappers não vale. E isso não tem fim, podemos passar anos discutindo isso (oras, já passamos anos discutindo isso!)</p>
<p>Vejamos uma definição (não oficial) na <a href="https://en.wikipedia.org/wiki/Object-oriented_programming_language">Wikipedia</a> : <em>“Linguagens chamadas ‘puro’ O.O., porque tudo neles são tratados consistentemente como um objeto, de primitivas como caracteres e pontuações, subindo o caminho todo até classes, protótipos, blocos, módulos, etc. Foram desenhados especificamente para facilitar, até mesmo reforçar, métodos O.O.. Exemplos: Smalltalk, Eiffel, Ruby.”</em></p>
<p>Como esquecer do venerado <a href="https://en.wikipedia.org/wiki/Bertrand_Meyer">Bertrand Meyer</a> e seu <a href="https://en.wikipedia.org/wiki/Eiffel_(programming_language)">Eiffel</a>, inspiração para todas as linguagens modernas com aspectos de objetos principalmente por uma funcionalidade que quase nenhum linguagem tem: assertions (<a href="https://en.wikipedia.org/wiki/Design_by_Contract">Design by Contract</a>), algo mais forte do que tipagem estática ou herança de interface.</p>
<p>Nessa definição de O.O., Java e Python não se encaixam porque elas preservam alguma natureza procedural. Esta <a href="https://archive.eiffel.com/doc/manuals/technology/oo_comparison/">tabela de comparação</a>, entre Eiffel, C++, Java e Smalltalk levaria muitos a crer que Eiffel é, de longe, a melhor linguagem. Fica obscuro porque ela não é a mais popular.</p>
<p>O máximo que podemos efetivamente afirmar sobre uma linguagem é se ela é <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing Complete</a> ou não. C++, Java, Ruby, Smalltalk, Python são todas Turing Complete. <span class="caps">SQL</span> não é. Uma linguagem muito promissora, por exemplo, é <a href="https://tinyurl.com/2n6o7g">Scala</a>. ela é uma linguagem orientada a objetos (no sentido que todo valor é um objeto), funcional (no sentido de que toda função é um valor), com tipagem forte e estática, que roda sobre a <span class="caps">JVM</span> (novamente, uma das melhores VMs já feitas). Ruby é uma linguagem O.O., com aspectos funcionais, tipagem forte e dinâmica, e interpretada. Smalltalk é O.O., sem aspectos funcionais relevantes, mas com tipagem forte e dinâmica e compilada para uma VM. Visual Basic é uma linguagem procedura, com aspectos de O.O., tipagem fraca e dinâmica e pré-compilada para um interpretador.</p>
<p>No final, a linguagem/plataforma que melhor levar seu projeto até o final é a vencedora (levar até o final e sem deixar mortos no meio do caminho, de preferência). Todo projeto nasce diferente, tem requerimentos diferentes (performance, reliability, maintainability, security, size, scalability, manageability, learning curve, industry support, market support, etc). Nunca pense: <em>“só pode haver um”_. Esse pensamento Highlander leva as pessoas a enxergar todo problema como pregos, pois a única ferramenta que ele conhece é um martelo (<a href="https://www.everything2.com/index.pl?node">Hammer and Nail problem</a></em>id=987739). Ou alguém pode querer inventar o framework para bater todos os frameworks, a linguagem para bater todas as linguagens. Apenas implementar todas as funcionalidades listadas acima não garante um bom produto. Acaba-se no famoso problema de se criar uma solução procurando por um problema.</p>
<p>Por isso fica minha recomendação – constante, persistente e insistente em todo artigo: não se limitem, <a href="https://en.wikipedia.org/wiki/Programming_language">aprender</a> mais e mais é o que nos torna melhores, em qualquer coisa. É o que chamamos de <a href="https://en.wikipedia.org/wiki/Culture">Cultura</a> (que vem de “cultivar”).</p>
<p></p>