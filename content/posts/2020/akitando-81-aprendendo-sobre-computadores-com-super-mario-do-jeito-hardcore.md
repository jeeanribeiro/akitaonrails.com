---
title: "[Akitando] #81 - Aprendendo sobre Computadores com Super Mario (do jeito Hardcore++)"
date: "2020-06-18T13:00:00.000Z"
tags: ["nes", "famicom", "6502", "assembly", "cc65", "game genie", "micro mages", "morphcat", "dotemu", "wonderboy", "tectoy", "fceux", "mesen", "tasvideos", "speedrun", "super mario", "steam", "akitando"]
years: "2020"
---

<p><iframe width="560" height="315" src="https://www.youtube.com/embed/hYJ3dvHjeOE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</p>
<h3>DESCRI√á√ÉO</h3>
<p>Errata: em 17:12 eu disse certo mas na equa√ß√£o faltou mostrar dividindo tudo por 2. Em 13:00 eu claramente faltei na aula porque 278 x 7 √© 1946 üòÖ</p>
<p>Voc√™ n√£o precisa ter assistido o video anterior pra entender este, mas certamente ajuda.</p>
<p>Hoje vou acelerar na miss√£o de fazer voc√™s entenderem como computadores em geral funcionam por baixo dos panos usando um Nintendinho e o Super Mario como guias nesta jornada.</p>
<p>N√£o tentem entender tudo na primeira assistida. Eu mesmo n√£o conseguiria. Assista at√© o fim pra ter a vis√£o completa depois retorne pra partes espec√≠ficas pra pegar em mais detalhes.</p>
<p>J√° aviso que os primeiros Vinte Minutos podem parecer um pouco devagar, porque vou complementar o que comecei no video anterior, mas garanto que depois disso vem o fil√© mignon do fil√© mignon. Vamos ver como se constr√≥i um emulador, como cartuchos funcionam, como come√ßar a editar jogos e a entender como se come√ßa a pensar em fazer jogos retr√¥, e vamos at√© falar de speedrun e hackear bugs de jogos. Tudo isso num √∫nico epis√≥dio!</p>
<p>Links:</p>
<ul>
  <li>Super Mario Bros. 3 - Wrong Warp (https://www.youtube.com/watch?v=fxZuzos7Auk)</li>
  <li>A Comprehensive Super Mario Bros. Disassembly (https://gist.github.com/1wErt3r/4048722)</li>
  <li>Lembra deles? Confira jogos brasileiros do Master System lan√ßados pela Tectoy! (https://blogtectoy.com.br/lembra-deles-todos-jogos-brasileiros-do-master-system-lancados-pela-tectoy/)</li>
  <li>Free NES assembler (https://bisqwit.iki.fi/source/nescom.html)</li>
  <li>Micro Mages (https://morphcatgames.itch.io/micromages)</li>
  <li>Nes Dev Wiki (https://wiki.nesdev.com/w/index.php/Nesdev_Wiki)</li>
  <li>Computer Archeology - The Legend of Zelda (https://www.computerarcheology.com/NES/Zelda/)</li>
  <li>6502 Instruction Set (https://www.masswerk.at/6502/6502_instruction_set.html)</li>
  <li>An introduction to 6502 math: addiction, subtraction and more (http://retro64.altervista.org/blog/an-introduction-to-6502-math-addiction-subtraction-and-more/)</li>
  <li>Explain Half Adder and Full Adder with Truth Table (https://www.elprocus.com/half-adder-and-full-adder/)</li>
  <li>Build a multiplying machine using NAND logic gates (https://codegolf.stackexchange.com/questions/12261/build-a-multiplying-machine-using-nand-logic-gates)</li>
  <li>Tool Assisted Game Movies (http://tasvideos.org/)</li>
  <li>RETRO INSECTIVORES: FINDING AND ELIMINATING BUGS IN NES DEVELOPMENT (https://megacatstudios.com/blogs/press/retro-insectivores-finding-and-eliminating-bugs-in-nes-development)</li>
  <li>FCEUX (https://sourceforge.net/projects/fceultra/)</li>
  <li>Zelda Screen Transitions are Undefined Behaviour (https://gridbugs.org/zelda-screen-transitions-are-undefined-behaviour/)</li>
  <li>NES Emulator Debugging (https://gridbugs.org/nes-emulator-debugging/)</li>
  <li>Two's Complement Multiplication (http://pages.cs.wisc.edu/~david/courses/cs354/beyond354/int.mult.html)</li>
  <li>NES Hello World (https://www.embed.com/nes/hello-world.html)</li>
  <li>DF Direct: CRT Displays - Was LCD A Big Mistake For Gaming? (https://www.youtube.com/watch?v=tvRyVZWuvQ4)</li>
  <li>DF Direct! Modern Games Look Amazing On CRT Monitors... Yes, Better than LCD! (https://www.youtube.com/watch?v=V8BVTHxc4LM)</li>
  <li>
    <p>Mod pra Wonderboy II Turma da Monica (https://www.youtube.com/watch?v=zQCm_y31SC0)</p>
  </li>
  <li>
    <p>Meu fork do emulador de NES em Go (https://github.com/akitaonrails/nes)</p>
  </li>
  <li>Meu c√≥digo do decodificador de c√≥digo de Game Genie (https://github.com/akitaonrails/gamegenie)</li>
</ul>
<p>Assinem estes canais:</p>
<ul>
  <li>Retro Game Mechanics Explained (https://www.youtube.com/channel/UCwRqWnW5ZkVaP_lZF7caZ-g)</li>
  <li>One Lone Coder (https://www.youtube.com/channel/UC-yuWVUplUJZvieEligKBkA)</li>
</ul>
<p></p>
<p></p>
<h3>SCRIPT</h3>
<p>Ol√° pessoal, Fabio Akita</p>
<p>O tema do video da semana passada √© um buraco de coelho de Alice no Pa√≠s das maravilhas. Estou demorando pra soltar videos porque cada assunto que eu esbarro vou pesquisar e abro mais uma d√∫zia de abas. Daqui a pouco vou encher meus 32GB de RAM s√≥ de abas. Computa√ß√£o retro √© uma √°rea gigantesca. Voc√™s n√£o imaginam quantas comunidades existem n√£o s√≥ colecionando itens antigos mas ainda desenvolvendo em assembly de MOS 6502 e outros processadores antigos como Z80, Intel 8088 e isso s√≥ no mundo dos 8-bits. Se entrar em 16-bits vai cair em processadores como o 65C816 do Super NES.</p>
<p>Eu reescrevi o script de hoje v√°rias vezes, numa das vers√µes eu estava gastando p√°ginas e p√°ginas s√≥ pra tentar explicar o problema da multiplica√ß√£o em processadores antigos. Mas ficou muito fora do escopo do canal. S√≥ pra dar um gostinho, no √∫ltimo video comecei a mostrar um pouco do Assembly do 6502 e algumas instru√ß√µes b√°sicas como LDA ou STA pra dar load no acumulador ou store do acumulador pra algum outro lugar.</p>
<p>Avan√ßando pra opera√ß√µes aritm√©ticas temos instru√ß√µes como ADC ou SBC pra adi√ß√£o e subtra√ß√£o. Voc√™ j√° come√ßaria co√ßando a cabe√ßa quando precisasse somar n√∫meros maiores do que 255, que √© o limite que cabe em 1 byte, ou 8-bits. Lembra que o 6502 √© uma CPU de 8-bits? Ent√£o todas as instru√ß√µes s√≥ conseguem trabalhar com 8-bits de uma s√≥ vez. Pra trabalhar com n√∫meros maiores a gente particiona o n√∫mero e calcula 1 peda√ßo de 1 byte de cada vez. Vamos entender um pouco mais disso.</p>
<p>Como todo mundo pelo menos j√° deve ter ouvido falar, chips como o 6502 s√£o feitos de componentes menores, como um transistor. Um transistor, em sua ess√™ncia √© um componente que funciona como um switch, ou interruptor. Acho que essa √© a imagem mais simples de ter na cabe√ßa. Voc√™ pode comprar transistors individualmente empacotados como um componente mais f√°cil de manipular num protoboard como esse aqui (video).</p>
<p>Ali√°s, no video anterior eu chamei isso de breadboard que √© como falam nos Estados Unidos, mas aqui se chama protoboard. Enfim, usando transistores √© poss√≠vel criar alguns dos circuitos mais simples de todos, as portas l√≥gicas, que s√£o pe√ßas fundamentais sobre as quais todo o resto √© montado. Por exemplo, voc√™ pode montar uma porta l√≥gica NOT num protoboard com um transistor, um resistor, um led pra ver a resposta, uma bateria e fios pra conectar. Uma porta NOT quando voc√™ manda 0 ele responde 1, ou quando manda 1 ele responde 0. Uma porta NOT pode ser feito com dois transistors, por exemplo.</p>
<p>Al√©m de NOT podemos montar outras portas fundamentais como OR, AND, NAND, XOR que √© exclusive OR e assim por diante. E com essas portas podemos montar coisas mais complicadas como uma CPU inteira. Com outras constru√ß√µes como flip flops, podemos montar mem√≥ria, e por a√≠ vai. √Ä primeira vista √© dif√≠cil de entender como opera√ß√µes simples como inverter bits pode ser √∫til. Vamos pensar numa opera√ß√£o um pouco mais complicada que queremos ter numa CPU, por exemplo somar dois n√∫meros.</p>
<p>Assumindo que todo mundo sabe somar. Pense uma conta besta, somar 28 mais 22. Voc√™ come√ßa somando 8 com 2, vai dar 10, coloca zero embaixo e sobe 1. A mec√¢nica interessante aqui √© esse "sobe um". Agora soma esse 1 que subiu com 2 do 28 e 2 do 22 e vai ter 50. Pra somar em bin√°rio √© exatamente a mesma coisa. Pra converter um n√∫mero decimal em bin√°rio, voc√™ vai dividindo por dois. 28 dividido por 2 √© 14, resto 0. 14 por 2 √© 7, resto 0, 7 por 2 √© 3, resto 1, 3 divido por 2 √© 1, resto 1. Ent√£o fica 11100. Pra ser 8 bits s√≥ completar os 3 zeros √† esquerda.</p>
<p>Fazendo mesma coisa com 22 fica 0001 0110. N√∫meros pequenos uma hora voc√™ lembra de cabe√ßa, mas pra n√∫meros maiores qualquer calculadora do Windows mesmo converte pra voc√™. Ou em qualquer linguagem de programa√ß√£o tem uma fun√ß√£o de formatar strings onde voc√™ passa um inteiro e diz que quer formatar com base 2. Num javascript basta chamar o m√©todo .toString com argumento 2 num n√∫mero.</p>
<p>Pra somar esses dois bin√°rios, voc√™ come√ßa da direita pra esquerda tamb√©m, zero mais zero √© zero. Depois zero e um √© um. 1 e 1 √© 2 que em bin√°rio √© 1 0, ent√£o coloca zero e sobe 1. 1 mais 1 mais zero, mesma coisa, coloca zero e sobe mais um. 1 + 1 + 1 √© 3, coloca 1 e sobe 1. 1 mais zero mais zero √© 1. E o resto √© zero. Ent√£o o resultado final √© 0011 0010. S√≥ parece dif√≠cil porque voc√™ ainda n√£o t√° acostumado a enxergar zeros e uns, mas a regra √© a mesma e usa a mesma mec√¢nica do "sobe um".</p>
<p>A m√°quina de adi√ß√£o mais simples que soma 2 bits √© chamado de half adder ou meio somador. Voc√™ liga uma porta AND com uma porta XOR e vai ter a soma e o carry bit. Carry √© o bit onde grava o "sobe 1". O meio somador vai fazer exatamente o que eu fui descrevendo agora. Se passar 0 e 0 a soma √© 0. Se passar 1 e 0 ou 0 e 1 a soma √© 1. Se passar 1 e 1 a soma √© 2, ent√£o baixa 0 e sobe 1 pro Carry bit. A vers√£o completa se chama full adder ou somador completo.</p>
<p>Um dos jeitos de montar um somador completo pode ser ligando duas portas XOR, duas portas AND e uma porta OR. Ou melhor ainda, ligando dois meio somadores. A diferen√ßa √© que al√©m dos 2 n√∫meros pra somar ele tamb√©m recebe o carry bit de entrada e com isso podemos cascatear m√∫ltiplos circuitos de somador completo um embaixo do outro, ligando o carry bit de sa√≠da de um somador na entrada do outro. Se quisermos somar com n√∫meros de 4-bits adicionamos 4 somadores completos em cascata. Pra 8-bits precisamos de 8 somadores. E com isso adquirimos um somador completo de 8-bits! (som de zelda)</p>
<p>Um circuito de somador completo pode ser montado de maneiras diferentes e com isso varia o n√∫mero de transistors, mas pense que na m√©dia vai ser alguma coisa na faixa de 10 transistors pra cada somador. Pra somar n√∫meros de 8 bits vamos precisar de no m√≠nimo uns 80 transistors. Pra hoje em dia isso n√£o parece grande coisa j√° que um processador A13 Bionic dos iPhone 11 Pro tem 10 bilh√µes de transistors. Um AMD Ryzen 7 3700X tem quase 6 bilh√µes de transistors e um AMD Epyc Rome, que √© pra servidores, tem mais de 39 bilh√µes de transistors. Lembrando que s√£o todos chips de 64-bits.</p>
<p>Nosso pobrezinho MOS 6502 de 8-bits tem na faixa de 3500 transistors, lembrem-se que estamos falando do meio dos anos 70. O que viemos fazendo depois, al√©m de aumentar mais e mais a densidade de transistors por cent√≠metro quadrado, foi adicionando novas funcionalidades como SIMD que s√£o instru√ß√µes de single instruction multiple data pra computa√ß√£o paralela, instru√ß√µes de virtualiza√ß√£o como VT-X ou AMD-V, instru√ß√µes pra criptografia como AES, sem contar que os chips hoje s√£o multi-core ent√£o √© como se fossem m√∫ltiplas CPUs apertadas no mesmo chip. Mas as instru√ß√µes fundamentais como somar bytes, carregar acumulador, incrementar contador de programas, atualizar apontador de pilha, e coisas assim que vimos no hello world da semana passada ainda √© similar.</p>
<p>Um primeiro insight √© que os chips hoje s√£o na ordem de 10 milh√µes de vezes mais densos de transistors que os chips dos anos 80 pra tr√°s. Por√©m isso n√£o se traduz necessariamente em programas 10 milh√µes de vezes melhor. Pegue o melhor da gera√ß√£o 8-bits que foi Super Mario 3 e compare com New Super Mario Bros rodando no Switch cujo SoC Tegra X1 tem na faixa de 7 bilh√µes de transistors com 4 cores ARM Cortex A57 ativos.</p>
<p>Vamos descer um pouco mais hardcore pra dar mais contexto com o tipo de CPU que estamos trabalhando. Adi√ß√£o eu disse que fazemos mais ou menos do mesmo jeito que voc√™ faria no papel somando digito a digito e subindo 1 quando precisa. Se hoje em dia temos transistors de sobra nas CPUs, nos 3500 que tinha num 6502, cada transistor contava. Ent√£o s√≥ era implementado o estritamente necess√°rio. Somadores completos numa cadeia de 8 bits est√° implementado na instru√ß√£o ADC.</p>
<p>Se recapitularmos sobre o pouco que aprendemos sobre assembly do 6502, pra realizar uma adi√ß√£o de n√∫meros de 8 bits, faz de conta, o n√∫mero 1 mais 2 poder√≠amos fazer assim.</p>
<pre><code>    LDA #$01
    ADC #$02
    STA $6000
</code></pre>
<p>Come√ßa com LOAD do n√∫mero 1 no acumulador, ADC que √© adi√ß√£o com carry onde passamos 2 e ele vai somar com o n√∫mero 1 que j√° tava no acumulador, da√≠ armazena ou Store do resultado que fica no A pra algum endere√ßo na mem√≥ria, como o endere√ßo $6000 que, no video anterior, ia mandar pro chip de trava e de l√° pro LCD. Isso √© uma coisa que hoje em dia voc√™ n√£o se preocupa porque as linguagens de programa√ß√£o j√° cuidam disso, mas o 6502 faz c√°lculos com n√∫meros de 8-bits. O valor m√°ximo que cabe em 8 bits sem sinal √© FF ou 255. O que acontece se eu tentar somar 255 + 255? Precisamos de mais bits.</p>
<p>S√≥ porque uma CPU √© de 8-bits n√£o quer dizer que n√£o podemos calcular n√∫meros maiores, mas pra fazer isso precisamos particionar o n√∫mero e lidar com peda√ßos dele. Por exemplo, digamos que tiv√©ssemos uma CPU decimal mas que s√≥ faz conta com n√∫meros de 2 d√≠gitos de cada vez, ent√£o de 0 at√© 99. Se somarmos 99 + 5 ter√≠amos 104. Precisar√≠amos gravar o 1 separado do zero quatro. No caso da soma, eu disse que todo somador completo lida com 1 bit do n√∫mero. A instru√ß√£o ADC √© como se fossem 8 somadores completos em cadeia pra 8-bits.</p>
<p>Uma nomenclatura que √†s vezes voc√™ vai esbarrar √© high order e low order. Quando lidamos com 16-bits, temos 2 bytes. O primeiro byte √† esquerda chamamos de high byte e o √∫ltimo √† direita de low byte. Dentro de cada byte tem 8-bits o bit mais √† esquerda √© o MSB ou Most Significant Bit e o √∫ltimo bit √© o LSB ou Least Significant Bit, literalmente bit mais significativo e menos significativo. Lembra quando expliquei sobre little endian no epis√≥dio anterior? √â pegar os 2 bytes e inverter, assim o low byte √© lido antes do high byte.</p>
<p>Voltando pra soma, toda vez que tiver um "sobe 1" ele vai ser gravado no registrador C. Antes de toda soma o certo √© usar a instru√ß√£o CLC, literalmente Clear C, pra limpar esse registrador. Mas podemos n√£o limpar tamb√©m. Lembra que falei que registradores funcionam como var√≠aveis globais? V√°rias instru√ß√µes deixam efeitos colaterais pra tr√°s, deixando registradores com a sobra do que foi processado. E podemos usar isso a nosso favor, come√ßar somando a primeira metade do n√∫mero at√© 8-bits, e depois somar a segunda metade que vai usar o carry no C e continuar a soma com o resto dos bits. Por exemplo, digamos que temos um n√∫mero grande, de 24-bits tipo o n√∫mero 2 milh√µes. Seriam 3 peda√ßos de 8 bits cada que podemos chamar de high, medium e low byte.</p>
<p>Declaramos ent√£o os 3 peda√ßos do primeiro n√∫mero A como A hi, A mid e A lo, depois B hi, B mid e B lo. Come√ßamos limpando o registrador C, fazemos a soma dos bytes low, que √© dar load no A low, adicionar com B low e guardar esse resultado parcial em B low; depois mesma coisa com os bytes medium e high. A soma final √© a jun√ß√£o dos tr√™s peda√ßos de B.</p>
<p>; ex: 8 milh√µes = $7A 12 00, A_hi = $7A, A_mid = $12, A_low = $00
  A_hi, A_mid, A_lo
  B_hi, B_mid, B_lo</p>
<p>START: CLC ; Clear C only to start.
  LDA A_lo
  ADC B_lo
  STA B_lo</p>
<pre><code>    LDA  A_mid  ; Note that here we don't re-clear C, but just
    ADC  B_mid  ; let it do its job of adding the 9th bit that
    STA  B_mid  ; didn't fit in the result of the previous byte's
                ; addition.
    LDA  A_hi
    ADC  B_hi
    STA  B_hi
</code></pre>
<p>Pense na sua linguagem favorita, voc√™ nunca se preocupa com isso, simplesmente escreveria <code>A + B</code>. Como voc√™ tem processamento e mem√≥ria de sobra e seus programas nunca s√£o particularmente complicados, mesmo que tenha desperd√≠cios, n√£o chega a ser um problema. Mas quando seus recursos s√£o extremamente limitados, desperdi√ßar bits √© um problema real. Desperdi√ßar ciclos tamb√©m, porque cada instru√ß√£o gasta alguns ciclos de clock. Nada sai de gra√ßa. Um processador moderno roda na faixa de 2Ghz a 5Ghz hoje em dia, mas um 6502 roda entre 1 a 3 Mhz.</p>
<p>Portanto em m√°quinas pequenas como o 6520 queremos tanto economizar a quantidade de mem√≥ria usada quanto o n√∫mero de instru√ß√µes pra n√£o desperdi√ßar clocks. Literalmente podemos fazer dezenas de milh√µes de instru√ß√µes a menos por segundo num 6502 do que num processador moderno de qualquer smartphone hoje. Fazer programas simples num computador excessivamente poderoso √© muito f√°cil, qualquer um faz. Eu sempre digo que voc√™ sabe quando um programador √© bom quando ele consegue programar num sistema com restri√ß√µes, porque a arte de programar √© conseguir tirar o m√°ximo que o hardware oferece.</p>
<p>Vamos dar outro exemplo besta. J√° sabemos como CPUs fazem adi√ß√£o. Subtra√ß√£o e multiplica√ß√£o √© a mesma coisa. Podemos desenhar circuitos como no caso do somador completo e implementar com transistors. Como falei antes, no 6502 temos a instru√ß√£o ADC pra adi√ß√£o e tamb√©m temos SBC pra subtra√ß√£o, mas n√£o tem multiplica√ß√£o.</p>
<p>Digamos que voc√™, que nunca estudou nada de engenharia ou ci√™ncias da computa√ß√£o pense numa forma de implementar multiplica√ß√£o s√≥ usando opera√ß√µes b√°sicas que falamos at√© agora como adi√ß√£o, o que voc√™ faria? Eu aposto como a solu√ß√£o mais imediata que a maioria pensaria seria via adi√ß√µes sucessivas. Por exemplo se quisermos multiplicar 278 vezes 7, voc√™ iria somando 278 sete vezes at√© dar 1148. Seriam s√≥ 7 adi√ß√µes e n√£o parece t√£o ruim assim. Aquele famoso caso de "testei aqui e no meu computador funciona".</p>
<p>Mas e se quisermos multiplicar 10 mil vezes 10 mil? Agora precisa fazer 10 mil somas pra chegar no resultado. Isso √© consideravelmente mais devagar e com n√∫meros maiores s√≥ vai piorando. Vamos usar tempos hipot√©ticos s√≥ pra ilustrar. Pra somar cada bloco de 8 bits digamos que precisariamos gastar uma instru√ß√£o de LOAD, uma de ADC e outra de STORE, cada um custando uns 5 ciclos de clock. 10 mil √© um n√∫mero que podemos representar em 2 bytes ou 16 bits. Ent√£o s√£o pelo menos 2 loads, 2 adc e 2 stores pra cada rodada.</p>
<p>Ent√£o temos 6 instru√ß√µes custando uma m√©dia de 5 ciclos de clock, ou seja 30 ciclos. Em 1 Mhz podemos ter no m√°ximo umas 33 mil sequ√™ncias dessa por segundo. Mas se precisamos executar 10 mil sequ√™ncias de soma dessas gastar√≠amos 1/3 de segundo ou pelo menos 300 milissegundos. Lembrando que estou considerando condi√ß√µes ideais de temperatura e press√£o, como a gente falava no col√©gio, mas provavelmente gastaria mais ciclos que isso. Parece pouca coisa mas 300 milissegundos √© mais tempo que leva pra voc√™ pedir uma p√°gina num site, ele processar, retornar o HTML e seu navegador renderizar. Ali√°s, se sua aplica√ß√£o web demora 300 milissegundos pra responder, isso √© considerado lento quase parando.</p>
<p>Pra variar, n√£o existe uma f√≥rmula universal de multiplica√ß√£o que tem 100% de melhor performance pra todos os casos. O bom senso √© o contr√°rio: f√≥rmulas universais costumam ser lentas. Isso √© uma coisa que, como programador, voc√™ precisa entender: existem f√≥rmulas que funcionam melhor pra casos diferentes. Por exemplo, no epis√≥dio anterior eu j√° disse como faz multiplica√ß√£o por 2: basta fazer um shift left, que √© o equivalente a adicionar um zero no final do bin√°rio e pronto, t√° multiplicado numa √∫nica instru√ß√£o.</p>
<p>Voc√™ n√£o conhece formas diferentes de multiplicar? Deixa eu contar um diferente. Existe um m√©todo ensinado no prim√°rio de escolas Russas que ficou famoso porque a gente associa tudo que √© russo com excel√™ncia em matem√°tica. Na real √© um m√©todo bom pra n√∫meros pequenos e n√£o √© particularmente bom pra computadores. √â chamado de m√©todo do campon√™s russo. Vou explicar de curiosidade.</p>
<p>O m√©todo √© assim: dobre o primeiro fator, divida o segundo fator pela metade. Se o segundo fator for par ignore e repita. Se o segundo n√∫mero for √≠mpar, some o primeiro fator com o anterior. Por exemplo, digamos que eu quero multiplicar 278 por 7 como falamos antes. Primeiro dobramos o primeiro fator. Multiplicar por 2 todo mundo consegue fazer de cabe√ßa e vai dar 556. Da√≠ 7 divido por 2 √© 3. 3 √© impar ent√£o somamos 556 com 278 e temos 834. Agora dobramos 556 de novo e vamos ter 1112. No segundo fator temos 3 dividido por 2 que √© 1, que √© impar, ent√£o somamos com 834 com 1112 e vamos ter 1.946. Como o segundo fator chegou a 1 acabamos e a resposta √© 1.946. Pode abrir uma calculadora a√≠ e checar.</p>
<p>N√£o √© dif√≠cil implementar isso em Assembly. Existe um site excepcional que √© a fonte de refer√™ncia de qualquer um que quer implementar um emulador de NES que √© o Wiki Nesdev e quando fala de multiplica√ß√£o ele implementa justamente esse algoritmo do campon√™s russo que fica assim:</p>
<p>https://wiki.nesdev.com/w/index.php/8-bit_Multiply</p>
<pre><code>;;
; Multiplies two 8-bit factors to produce a 16-bit product
; in about 153 cycles.
; @param A one factor
; @param Y another factor
; @return high 8 bits in A; low 8 bits in $0000
;         Y and $0001 are trashed; X is untouched
.proc mul8
prodlo  = $0000
factor2 = $0001
  ; Factor 1 is stored in the lower bits of prodlo; the low byte of
  ; the product is stored in the upper bits.
  lsr a  ; prime the carry bit for the loop
  sta prodlo
  sty factor2
  lda #0
  ldy #8
loop:
  ; At the start of the loop, one bit of prodlo has already been
  ; shifted out into the carry.
  bcc noadd
  clc
  adc factor2
noadd:
  ror a
  ror prodlo  ; pull another bit out for the next iteration
  dey         ; inc/dec don't modify carry; only shifts and adds do
  bne loop
  rts
.endproc
</code></pre>
<p>Voc√™ d√° load do multiplicador no acumulador, load do multiplicando no registrador Y e roda essa rotina e ele vai gravar o low byte do resultado no endere√ßo $0000 e o high byte em A. Lembra que n√∫meros maiores que 8-bits fica particionado em m√∫ltiplos bytes? O resultado de uma multiplica√ß√£o costuma ser um n√∫mero com o dobro de bytes dos fatores, ent√£o multiplicar 2 n√∫meros de 8 bits d√° um resultado de 16 bits.</p>
<p>Esse algoritmo gasta em torno de 150 ciclos. Se seu programa for ter poucas multiplica√ß√µes pode ser suficiente. Mas qualquer opera√ß√£o que gasta mais que 100 ciclos num 6502 n√£o √© exatamente r√°pido. Existem maneiras mais r√°pidas que isso. E aqui vem outro insight que como programador voc√™ precisa ter na cabe√ßa. Algoritmos costumam ser um balan√ßo de dois fatores: se voc√™ quiser economizar mem√≥ria vai acabar gastando mais ciclos de processamento. Se quiser velocidade economizando ciclos provavelmente vai gastar mais mem√≥ria. Por exemplo, vamos pensar um pouco mais: como voc√™ faria multiplica√ß√µes r√°pido no prim√°rio, sem calculadora?</p>
<p>Pra n√∫meros pequenos voc√™ provavelmente teria que ter decorado a tabuada, lembram disso? Tenho certeza que a maioria odiava ter que decorar a tabuada. Mas lembrem de uma coisa, a tabuada √© uma tabela pr√©-calculada. Voc√™ procura o multiplicando e o multiplicador e instantaneamente tem a resposta. Imagine uma tabela pr√©-calculada pra todos os n√∫meros que cabem em 8-bits. Da√≠ basta achar a posi√ß√£o na matriz com o resultado direto. Voc√™ vai gastar ciclos pra pr√©-calcular a tabela da primeira vez ou pode ler direto a tabela de uma ROM. O problema dessa solu√ß√£o √© que f√°cil f√°cil ela vai ocupar 16 kilobytes de espa√ßo ou mais. Considerando que um Super Mario Bros inteiro cabe em 40 kilobytes estamos falando em gastar 1 ter√ßo disso s√≥ numa tabela de n√∫meros, o que seria um enorme desperd√≠cio.</p>
<p>Uma tabela pr√©-calculada √© o que chamamos de lookup table e isso √© uma t√©cnica usada em todos os lugares da computa√ß√£o. Voc√™ que faz desenvolvimento web provavelmente j√° usou ou vai usar isso. Por exemplo quando faz cache com um Redis ou Memcache, √© um lookup table. Quando cria √≠ndices numa tabela de banco de dados, isso √© um tipo de lookup table. O problema √© que se essa tabela for grande demais, o tempo pra procurar na tabela tamb√©m pode come√ßar a ser um problema, fora desperd√≠cio de espa√ßo caso voc√™ n√£o planeje direito.</p>
<p>Mas como seria uma maneira melhor ent√£o? E aqui a matem√°tica nos ajuda. Se voc√™ estudou √Ålgebra e trigonometria n√£o vai achar estranho o que vou dizer a seguir. Uma multiplica√ß√£o de dois fatores a e b pode ser descrita de maneiras diferentes. Por exemplo, ela pode ser a exponencial da soma dos logaritmos de a e b. Se quiser ser mais complicado pode ser a soma do cosseno de x mais y com o cosseno de x menos y, tudo dividido por 2. Sendo que x √© o arco cosseno de a que tamb√©m √© chamado do cosseno inverso. Arco cosseno √© usado pra determinar o √¢ngulo do cosseno em radianos. Y da mesma forma √© o arco cosseno de b.</p>
<p>Continuando, a vezes b pode ser tamb√©m o quadrado de a mais b, menos o quadrado de a, menos o quadrado de b, tudo dividido por 2 ou, finalmente, pode ser o quadrado de a mais b menos o quadrado de a menos b tudo dividido por 4. E essa op√ß√£o final √© que nos interessa, pois podemos reduzir a f√≥rmula pra ser a subtra√ß√£o de a mais b aplicado numa fun√ß√£o F, com a menos b na mesma fun√ß√£o F, sendo essa fun√ß√£o F o quadrado do n√∫mero que passarmos dividido por 4.</p>
<p>A parte importante √© que decompomos o problema da multiplica√ß√£o numa adi√ß√£o dos fatores, subtra√ß√£o dos fatores e subtra√ß√£o do resultado da tal fun√ß√£o F. E a essa fun√ß√£o reduz o tamanho do lookup table pra em vez de ser todos os poss√≠veis resultados da multiplica√ß√£o de todos os n√∫meros de 8-bits, pra simplesmente ter uma tabela s√≥ com o resultado da multiplica√ß√£o do quadrado dos n√∫meros. Ou seja, de 1 vezes 1, de 2 vezes 2, de 3 vezes 3 e assim por diante, que √© uma quantidade pr√©-calculada ordens de grandeza menor, caindo dos 16 kbytes que eu falei pra talvez meio kbyte.</p>
<p>E pra calcular o quadrado de todos os n√∫meros tamb√©m vai ser r√°pido porque existe a propriedade que o quadrado do n√∫mero √© o quadrado do n√∫mero anterior mais um n√∫mero impar. Quadrado de 1 √© zero mais 1. Quadrado de 2 √© o 1 anterior mais o pr√≥ximo impar que √© 3, resultado 4. Quadrado de 3 √© 4 mais o pr√≥ximo impar 5 que d√° 9. Quadrado de 4 √© 9 mais o impar 7 que d√° 16. Quadrado de 5 √© 16 mais o pr√≥ximo impar 9 que d√° 25 e assim por diante.</p>
<p>E como eu disse no come√ßo, d√° pra ir longe estudando sobre assembly. Outros assuntos que tava pensando em cobrir neste epis√≥dio inclu√≠am o conceito de complementar de dois, n√∫meros inteiros com sinal pra lidar com negativos, algoritmo de Booth pra multiplica√ß√£o e muito mais. Mas √© teoria demais pra um √∫nico video, por hoje vou parar por aqui. Mas eu queria gastar pelo menos um pouco de tempo mostrando essa linha de racioc√≠nio pra voc√™s entenderem que n√£o, hoje em dia voc√™ dificilmente vai gastar tempo implementando uma multiplica√ß√£o na m√£o. Toda CPU j√° implementa as melhores f√≥rmulas em hardware e pra quem precisa de casos espec√≠ficos existem bibliotecas voltadas pro campo cient√≠fico que otimizam os piores casos.</p>
<p>Mas √© importante voc√™ entender que tudo que uma linguagem te oferece, cada pequena coisinha insignificamente como aquele mero asterisco de multiplica√ß√£o teve milhares de horas homens de pesquisa, experimenta√ß√£o, otimiza√ß√µes. Literalmente muito suor e l√°grimas at√© chegar no estado da arte que voc√™ usa hoje sem nem pensar. √â isso que significa subir nos ombros de gigantes, porque √© com o conhecimento testado e acumulado de centenas de anos de matem√°tica que esse asterisco de multiplica√ß√£o se tornou poss√≠vel e voc√™ consegue multiplicar dois n√∫meros de praticamente qualquer tamanho em microssegundos.</p>
<p>E tamb√©m √© pra entender que muita coisa hoje ainda n√£o tem uma f√≥rmula perfeita. Eu disse que temos CPUs com dezenas de milh√µes de vezes mais transistors que um 6502 mas ainda assim n√£o temos programas dezenas de milh√µes de vezes melhores. Isso porque muitas partes do software que usamos ainda n√£o t√° rodando da melhor forma poss√≠vel. Grande parte do que √© o trabalho de um programador √© n√£o ignorar os problemas e parar pra tentar encontrar formas mais inteligentes de fazer o computador processar.</p>
<p>Muito bem, vamos voltar ao nosso nintendinho. Assim como no exemplo do protoboard do Ben Eater, o PCB que √© sigla pra Printed Circuit Board ou placa de circuito impresso, cont√©m o c√©rebro que √© o 6502 e diversos outros chips como chip de RAM, chip de VRAM que √© mem√≥ria de v√≠deo, e outros componentes como pra ligar seus controles. Tem a PPU que √© o Picture Processing Unit ou unidade de processamento de imagens que √© a vers√£o primitiva do que hoje voc√™ chamaria de GPU. E tem o APU ou audio processing unit pra gerar som.</p>
<p>O nintendinho j√° foi t√£o dissecado nas √∫ltimas d√©cadas que temos documenta√ß√£o super completa de cada componente em detalhes suficiente pra ter muita gente fabricando chips e PCB novos. Voc√™ consegue literalmente comprar um hardware moderno de nintendinho hoje se quiser, e ele vai ser 100% compat√≠vel com qualquer cartucho que voc√™ tenha guardado.</p>
<p>Mas pro que me interessa, a documenta√ß√£o √© t√£o boa que √© poss√≠vel criar emuladores em software que se comportam exatamente como o hardware. Eu n√£o sei se voc√™s conseguem entender a beleza disso. Todo hardware tem a capacidade de simular o comportamento de outro hardware via software. E praticamente toda linguagem de programa√ß√£o consegue representar qualquer hardware.</p>
<p>Tendo documenta√ß√£o t√£o completa como o Wiki Nesdev que eu mencionei antes, poder√≠amos escrever nosso pr√≥prio emulador. E como algu√©m faria isso? √â um processo mais trabalhoso do que dif√≠cil porque voc√™ precisa ter o trabalho meticuloso de implementar cada detalhe que t√° nas documenta√ß√µes, mas por exemplo, podemos come√ßar criando um projeto vazio, digamos usando a linguagem Go. Ali√°s, como o nintendinho √© bem antigo, qualquer linguagem hoje consegue simular um 6502 e os outros componentes.</p>
<p>N√£o existe "O" jeito correto de se escrever um software. Se voc√™ pegar diferentes emuladores de nintendinho vai ver que eles s√£o organizados e escritos de maneiras diferentes. S√≥ com experi√™ncia e muitos testes voc√™ vai chegar no que √© o melhor balan√ßo entre legibilidade e efici√™ncia. Mas pra ser simples podemos pensar nos componentes principais que eu listei. O primeiro elemento que queremos emular √© o console, ent√£o come√ßamos criando um arquivo chamado console.go e dentro definimos o tipo Console como uma estrutura. E n√£o se preocupe se voc√™ nunca viu Go, n√£o √© relevante entender cada linha do c√≥digo hoje, s√≥ o racioc√≠nio. Estude depois com calma.</p>
<p>Essa estrutura vai declarar ponteiros pra CPU, pro APU, pro PPU, pro cartucho, pros dois controles, pra um tro√ßo que vou explicar depois chamado Mapper, e delimitamos a RAM que √© s√≥ um array. Lembram todos aqueles hexadecimais que eu falei no video anterior? Pense nesses n√∫meros como posi√ß√µes no array. Mem√≥ria √© isso: uma listona de bytes. Agora precisamos criar arquivos pra cada um desses componentes e definir as estruturas de cada um. O pr√≥ximo √© o arquivo cpu.go.</p>
<p>A estrutura CPU vai ter muitos dos elementos que eu expliquei no v√≠deo anterior. Come√ßamos definindo uma refer√™ncia pra uma estrutura de Memory que vou explicar depois. Da√≠ definimos PC que √© o contador de programa como um inteiro gigante de 64-bits, e nem precisava ser t√£o grande porque ele s√≥ aponta pro endere√ßo da pr√≥xima instru√ß√£o, ent√£o 16-bits bastava. Vamos definir o SP que √© o apontador de pilha como um inteiro de 16-bits. Da√≠ os registradores todos de 8 bits, ou seja 1 byte. Temos o acumulador A, o X, o Y, o C, Z, I, D, B, U, V, N. E por fim temos uma √∫ltima estrutura importante, um array de instru√ß√µes.</p>
<p>Lembra que cada instru√ß√£o como LDA tem um hexadecimal associado, que √© basicamente o endere√ßo da localiza√ß√£o dessa instru√ß√£o? Pois √©, precisamos colocar cada opcode na posi√ß√£o correta nessa lista. Quando quisermos achar a instru√ß√£o 0xa9 que √© o LDA vamos pra posi√ß√£o 0xa9 que √© a posi√ß√£o 169 nessa lista. Da√≠ vamos encontrar a refer√™ncia pra uma fun√ß√£o de Go. Agora precisamos implementar cada uma dessas fun√ß√µes.</p>
<p>Por exemplo, o nosso LDA sabemos que vai escrever o valor no registrador A que √© o acumulador. Ent√£o em Go √© simplesmente associar o valor do argumento na vari√°vel A da CPU.</p>
<p>Sabemos tamb√©m que JSR √© o Jump pra uma subrotina, o que ele faz √© empurrar o endere√ßo no contador de programas pra pilha e sobrescrever o contador de programa com o endere√ßo da subrotina pra onde tem que pular.</p>
<p>E assim vai, tem que escrever uma fun√ß√£o pra cada instru√ß√£o que existe de acordo com a especifica√ß√£o na documenta√ß√£o do 6502. Uma vez feito tudo isso podemos criar o inicializador NewCPU que vai alocar a estrutura que definimos. Esse inicializador recebe uma refer√™ncia pra estrutura de console que criamos antes pra passar pra essa nova estrutura chamada Memory. Deixa esse Memory de lado que ainda n√£o √© hora pra ele. Em seguida criamos e populamos a tal tabela com refer√™ncias pras instru√ß√µes que criamos. Finalmente criamos uma rotina de reset.</p>
<p>Reset √© o que voc√™ pensou mesmo: o equivalente a voc√™ apertar o bot√£o reset que todo console e computador tem. A id√©ia √© limpar o contador de programas pra apontar pro endere√ßo 0xFFFC, lembra no epis√≥dio anterior que quando o 6502 inicializa a primeira coisa que ele faz √© ir no endere√ßo 0xFFFC procurar a primeira instru√ß√£o do programa? Pois √©. E em seguida limpamos o apontador de pilha pra iniciar em 0xFD. Isso √© pra relembrar a import√¢ncia desses dois registradores, porque √© com eles que conseguimos executar um programa.</p>
<p>Tem mais coisas que precisam ser feitas pra CPU ficar completa mas por agora vamos pular pra essa tal de Memory criando um arquivo memory.go. A estrutura em si √© muito simples. Ela s√≥ vai apontar pra uma refer√™ncia √† estrutura de Console que j√° definimos antes. A parte importante come√ßa com a fun√ß√£o de leitura Read. Ele recebe um endere√ßo e vai devolver algum valor que teoricamente est√° em alguma lugar na tal mem√≥ria.</p>
<p>Aqui come√ßa a diferen√ßa de um nintendinho e outros computadores que usam o processador 6502 como um Atari ou Apple II, o mapa de mem√≥ria. No epis√≥dio anterior eu expliquei que temos endere√ßos de 16-bits ent√£o podemos mapear do endere√ßo 0x0000 at√© 0xFFFF, da√≠ dividimos esse espa√ßo e por exemplo a CPU ia procurar no EEPROM se pass√°ssemos endere√ßos acima de 0x8000. Ou seja, arbitrariamente definimos que certos chips respondem a certos endere√ßos.</p>
<p>A grosso modo, do endere√ßo 0x0000 at√© 0x07FF temos 2 kilobytes de RAM. Nos endere√ßos de 0x2000 a 0x2007, que √© bem curto, temos registradores pra PPU. De 0x4000 a 0x4017 acessamos a APU e registradores de I/O como os controles e s√≥ de 0x8000 a 0xFFFF temos o equivalente a uns 32 kilobytes reservados pra endere√ßos que mapeiam pra algum lugar do cartucho. Em particular se acessarmos acima do endere√ßo 0x6000 temos esse neg√≥cio que colocamos no c√≥digo chamado Mapper. Agora voc√™s precisam entender os truques que eram usados em consoles com cartuchos.</p>
<p>Se sua hist√≥ria com games come√ßa s√≥ depois do Playstation 1, voc√™ t√° acostumado a ter os games em CDs, DVDs, Blu-Ray ou instalados no HD do seu computador. √â de praxe que toda vez tem que esperar o famoso "Loading", que √© o tempo do computador come√ßar a carregar os primeiros bytes do jogo na RAM pra s√≥ depois conseguir come√ßar a jogar. Da√≠ a cada fase tem que carregar novos bytes pra RAM e jogar fora os bytes da fase anterior que n√£o vai precisar mais. Isso √© necess√°rio porque n√£o cabe todo o jogo na mem√≥ria. Um computador muito bom hoje tem 16 GB, mas qualquer jogo moderno tem 30 GB, 40GB, alguns jogos podem ter absurdos 100GB. Obviamente n√£o cabe tudo na RAM ent√£o precisa ir carregando e descarregando de peda√ßo em peda√ßo.</p>
<p>Com cartuchos √© diferente. O que tem num cartucho s√£o chips de ROM, como expliquei no epis√≥dio anterior. Ent√£o quando voc√™ pluga o cartucho no console, n√£o existe loading, n√£o tem que carregar nada e ele pode iniciar imediatamente porque a CPU acessa os endere√ßos diretamente da ROM, sem precisar carregar o jogo em mem√≥ria. O cartucho "√â" a mem√≥ria. Entenderam? Diferente de CD ou HD, a ROM do cartucho j√° tem velocidade m√°xima de acesso, igual da RAM. Da mesma forma que a CPU consultaria um endere√ßo na RAM, no caso pedindo endere√ßos de 0x0000 a 0x07FF, quando ele precisa de dados do jogo ele pede nos endere√ßos acima de 0x8000 at√© 0xFFFF.</p>
<p>Por isso jogos de consoles antigos carregam instantaneamente e n√£o tem loading entre fases e tudo √© r√°pido. Um dos maiores gargalos ainda n√£o resolvidos em games modernos de fato √© a lentid√£o do I/O, n√£o s√≥ do HD mas de toda a cadeia que carrega dados, incluindo barramento, controlador e tudo mais. Inclusive √© isso que a nova gera√ß√£o de consoles PS5 e Xbox Series X est√£o tentando combater colocando os SSDs e controladores mais r√°pidos do mercado pra minimizar ao m√°ximo o tempo de carregar coisas do disco. Mesmo assim o tempo nunca vai ser zero como era nos cartuchos.</p>
<p>Vou repetir o que eu disse antes: programa√ß√£o √© sempre um trade off, uma troca. Cartuchos tem tempo quase zero de acesso porque ele √© direto um chip de mem√≥ria. O problema √© que chips de ROM s√£o muito mais caros de produzir comparado a discos de HD ou Blu-Rays. √â bem mais caro. A compara√ß√£o mais √≥bvia foi na transi√ß√£o dos cartuchos pro CD quando saiu o Playstation 1 e o concorrente na √©poca era o Nintendo 64 que preferiu usar cartuchos pelas raz√µes que eu acabei de falar.</p>
<p>Jogos de Playstation podiam ter videos e muito mais conte√∫do porque num CD daquela √©poca era poss√≠vel colocar at√© 650 megabytes de dados. Em compara√ß√£o um dos maiores cartuchos de Nintendo 64 era Conker's Bad Fur Day que tinha enormes 60 megabytes, ou seja mais de 10 vezes menos espa√ßo e o cartucho ainda custava mais caro. Os lend√°rios Zelda Ocarina of Time e Majora's Mask eram cartuchos de menos de 30 megabytes. Por isso jogos de Nintendo 64 raramente tinham algum video e tamb√©m por isso preferiam usar o m√≠nimo de texturas nos modelos em 3D, porque texturas s√£o imagens bitmap que consomem muito espa√ßo.</p>
<p>Voltando pra era dos 8-bits. Um cartucho como do Super Mario original tem 40 kilobytes, portanto male male encaixa no nosso espa√ßo de endere√ßos reservados pra ROM. Mas um Super Mario 3 tem 385 kilobytes, quase 10 vezes mais bytes que o original. Um dos jogos mais pesados do nintendinho √© Kirby's Adventure e se voc√™ rodar vai ver um dos games mais bem elaborados pro nintendinho, chega perto do que seria um jogo de Super Nintendo. Tamb√©m pudera, o cartucho dele tem quase 800 kilobytes, perto de 1 megabyte.</p>
<p>Mas como √© poss√≠vel endere√ßar isso tudo de bytes s√≥ com endere√ßos de 16-bits? Agora vem o segundo grande fato sobre cartuchos: eles n√£o tem s√≥ chips de ROM. Na realidade um cartucho √© uma placa de expans√£o, um PCB completo. Quando falo em placa, pense mesmo como quando voc√™ compra uma placa gr√°fica como um novo NVIDIA RTX e espeta no slot PCI Express na placa m√£e do seu computador. Encaixar um cartucho no console √© a mesma coisa.</p>
<p>Num PCB voc√™ pode plugar n√£o s√≥ ROM como qualquer outro componente. Por exemplo, voc√™ pode colocar um chip de SRAM e uma bateria de l√≠tio e boom, voc√™ acabou de ganhar a capacidade de salvar o jogo. S√≥ que isso torna o cartucho ainda mais caro, por isso nem todo jogo podia salvar. Um dos chips mais famosos se voc√™ jogou Super Nintendo foi o chip Super FX, que literalmente era uma placa primitiva 3D que permitiu jogos como Star Fox. O processo √© o mesmo, o chip vem no PCB do cartucho.</p>
<p>Voc√™ literalmente poderia enfiar um nintendinho inteiro dentro de um cartucho. Mas s√≥ isso n√£o responde a pergunta de como fazia pra um Kirby ter quase 1 mega de dados. N√£o basta s√≥ enfiar mais chips de ROM se n√£o temos endere√ßos suficientes pra passar de 32 kilobytes. Endere√ßos funcionam como o nome diz, √© como se tiv√©ssemos uma rua de casas e s√≥ tivesse 32 n√∫meros, da casa 33 em diante ficaria sem n√∫meros. Se o carteiro precisasse entregar alguma coisa nessas casas como ele encontra?</p>
<p>E se nessa rua coloc√°ssemos um s√≠ndico? Que separasse a rua em blocos? Da√≠ teria casa de 1 a 32 no bloco A, casas de 1 a 32 no bloco B e assim por diante. Continua s√≥ tendo 32 n√∫meros mas dependendo do bloco sempre encontrar√≠amos uma casa diferente. E √© exatamente isso que o nintendinho faz. No cartucho, al√©m de vir mais ROM ele vem com um s√≠ndico, um controlador que chamamos de Mapper.</p>
<p>Como o nome diz, Mapper √© um mapeador. Em vez de blocos na rua do nosso exemplo a mem√≥ria ROM √© dividida em Banks ou bancos. E a t√©cnica pra enxergar mais mem√≥ria se chama Bank switching. A CPU continua s√≥ conseguindo enxergar dos endere√ßos 0x8000 a 0xFFFF mas ele pode pedir pro Mapper trocar os banks, assim como no exemplo dos blocos da rua. Os banks costumam ter 16 kilobytes de tamanho e podemos ter v√°rios banks, ent√£o se montarmos o cartucho com ROM suficiente pra 50 banks de 16 kilobytes, vamos ter os quase 800 kilobytes do jogo Kirby.</p>
<p>Agora vem a parte cabeluda pra fazer emulador de NES: n√£o basta s√≥ escrever c√≥digo que representa o console, precisa tamb√©m emular os chips que vem nos cartuchos, em particular esses mappers. Voc√™ poderia imaginar que deve ter alguns poucos modelos de mappers. Mas que nada, se olhar a biblioteca toda de games de nintendinho existem 407 mappers que foram encontrados e documentados. Por sorte, se voc√™ cobrir os mappers da pr√≥pria nintendo e alguns de marcas famosas como Konami, j√° cobre a maior parte dos jogos. Muitos mappers s√≥ existem em jogos muito obscuros, feitos na China ou lugares assim.</p>
<p>Se voc√™ olhar de novo no wiki da nesdev vai encontrar o c√≥digo que vem no cartucho que identifica qual mapper ele tem. No arquivo de Memory ele vai selecionar um Mapper baseado nesse c√≥digo identificador que ler da ROM. Da√≠ precisamos de cada um dos Mappers, que precisam responder √†s mesmas fun√ß√µes. Por isso no nosso arquivo de mapper vamos definir uma interface que todos os mappers v√£o ter que implementar. Basicamente definimos o que um Mapper precisa obrigatoriamente fazer, que √© ler da ROM, gravar na RAM e coisas assim.</p>
<p>No inicializador pegamos o cartucho associado no console. Depois que carregarmos uma ROM ele vai preencher esse campo Mapper com seu c√≥digo identificador, e com isso podemos checar qual mapper vamos ter que carregar. Neste pequeno emulador em Go vai ter s√≥ alguns dos principais. De curiosidade esse √∫ltimo mapper c√≥digo 225 √© que permite aqueles cartuchos de 52 jogos em 1 que voc√™ j√° deve ter visto por a√≠. Um cartucho desses tinha 6 chips de ROM com meio megabyte cada.</p>
<p>N√£o vou entrar no detalhe de cada um, sen√£o a gente fica aqui at√© o ano que vem, mas s√≥ pra mostrar um, podemos criar um arquivo pro mapper 2. Lembrando que no nosso caso, usando m√°quinas modernas, n√£o temos esses limites pequenos de 16-bits. Podemos carregar a ROM de um cartucho como um arrayz√£o cont√≠nuo de bytes, seja l√° quantos bytes tiver porque temos espa√ßo pra mapear tudo. Ent√£o recebemos o endere√ßo que o CPU manda e mapeamos com esse arrayz√£o.</p>
<p>No caso, o que nos interessa √© que quando carregamos a ROM os bytes s√£o identificados como regi√µes distintas, sendo as duas principais o PRG e CHR. PRG s√£o bytes de programa. CHR s√£o os bytes de caracteres, que √© a √°rea onde normalmente est√£o os tiles. Eu sempre chamo de tiles mas se for traduzir √© como se fossem azulejos. Tiles, azulejos, caracteres, s√£o termos que significam a mesma coisa.</p>
<p>O princ√≠pio de tiles √© simples. Um CPU como o 6502 n√£o fica dando instru√ß√µes pra escrever pixel a pixel na tela. Ele pede pra escrever tiles. Pense num nintendinho como um editor de textos. Um editor n√£o escreve pixel a pixel na tela, ele escolhe uma letra de alguma fam√≠lia de fontes, digamos Arial, e passa o c√≥digo que representa ela. E o Windows ou MacOS da vida que vai se encarregar de realmente desenhar os pixels.</p>
<p>No nintendinho quem se encarrega de desenhar os pixels √© o chip chamado de PPU que eu falei que √© a unidade de processamento de pixels. O CPU n√£o entende pixels, ele entende tiles. Significa que o PPU tem que trabalhar bastante pra desenhar pixel a pixel. Inclusive o clock do PPU √© maior que do CPU. Mas a CPU s√≥ precisa mandar um byte pra identificar blocos de 8 por 8 pixels de uma vez s√≥, em vez de mandar 64 comandos independentes pra cada um desses pixels.</p>
<p>Se voc√™ √© de web front-end j√° lidou com algo assim, √© como os sprites de CSS. Ali√°s a t√©cnica de sprites de CSS n√£o √© novidade, isso √© uma t√©cnica antiga. Outra t√©cnica antiga s√£o fontes com imagens, como a Font Awesome que todo site hoje usa pra desenhar icones. A mem√≥ria CHR da ROM que eu falei √© como se fosse uma Font Awesome, literalmente caracteres. Cada caracter, ou fonte, √© um tile. Acho que assim voc√™s conseguem visualizar na cabe√ßa. Consoles antigos assim sequer tem fontes ou tabela de letras. Cada jogo define suas fontes e o c√≥digo das letras, n√£o tem um padr√£o como ASCII ou Unicode.</p>
<p>A PPU enxerga a resolu√ß√£o m√°xima de 256 por 240 pixels, e a CPU s√≥ enxerga uma grade de 16 por 15 espa√ßos onde cabem os tiles. √â parecido com um computador DOS antigo que tem resolu√ß√£o de 640 x 480 mas em modo DOS s√≥ enxerga 80 colunas por 25 linhas de texto. O PPU tamb√©m s√≥ consegue enxergar 8 kilobytes de tiles de cada vez, ent√£o toda vez que precisamos de tiles diferentes, o CPU pede pro Mapper trocar o banco por outro. Existem dois excelentes emuladores pra quem quer aprender a programar jogos de verdade de nintendinho. Um deles √© o FCEUX que acho que √© o mais conhecido e o outro √© o Mesen que eu acho que tem ferramentas mais modernas.</p>
<p>Voc√™s entenderam o que fizemos at√© agora? Eu fui estruturando o nintendinho como c√≥digo de Go. Cada aspecto dele s√£o estruturas de dados normais como arrays e bytes. Bytes na mem√≥ria que sabemos exatamente onde est√£o e com isso podemos consultar a qualquer momento. Seja o emulador feito em Go, em C ou C++ vai ser a mesma coisa. O emulador Mesen implementa de forma parecida mas al√©m de s√≥ emular ele exp√µe essas estruturas de forma visual em tempo real. Por exemplo, podemos abrir um visualizador da mem√≥ria da PPU e organizar pra vermos os bitmaps.</p>
<p>E olha s√≥ o que tem na mem√≥ria da PPU, esses s√£o os tiles. Cada tile √© um quadrado de 8 por 8 pixels. Se eu n√£o estou enganado, podemos associar at√© 4 cores pra cada um, dentre 12 cores de uma paleta, num total de 4 paletas que posso escolher. Em outra aba podemos ver as 12 cores da paleta de background e outras 12 cores da paleta pros sprites. Se voc√™ j√° brincou de front-end, HTML e CSS certamente j√° viu c√≥digo de cores em hexadecimal, √© a mesma coisa.</p>
<p>Como a localiza√ß√£o dessa √°rea CHR na ROM √© conhecida, podemos editar o que tem l√°. Os tiles s√£o bitmaps n√£o comprimidos. Hoje em dia voc√™ t√° acostumado a lidar com imagens comprimidas como JPEG que usa um algoritmo lossy, ou seja, que perde detalhes da imagem pra reduzir o tamanho. Um bitmap √© exatamente o que o nome diz, um mapa de bits, nas posi√ß√µes exatas pra formar a imagem e sem compress√£o.</p>
<p>S√≥ pra mostrar como podemos afetar o jogo, com o Mesen rodando podemos editar as cores da paleta de background e trocar a cor do c√©u de azul pra outra cor. Ou podemos mexer na paleta de sprites e trocar a cor do Mario. Voc√™ pode mudar completamente a apar√™ncia do jogo s√≥ de ajustar as cores dessa forma.</p>
<p>Repetindo, pense na tabela de tiles como se fosse uma tabela de fontes de letras. Ali√°s, o nintendinho sequer tem fontes. Ele n√£o tem um sistema operacional, o jogo come√ßa rodando direto no hardware, sem nenhuma camada intermedi√°ria pra ajudar. Ent√£o se um jogo quer escrever textos na tela, ele pr√≥prio precisa embutir tiles de fontes. E de fato voc√™ vai ver que normalmente come√ßando no endere√ßo zero dessa √°rea CHR costuma ter letras, n√∫meros e s√≠mbolos. Aqui o n√∫mero zero √© a posi√ß√£o zero mesmo, o n√∫mero um √© posi√ß√£o um e assim por diante. E come√ßando do zero at√© a letra F fica bonitinho de 0 a F em hexadecimal.</p>
<p>Lembra quando usamos no Linux a ferramenta hexdump ou xxd e na terceira coluna ele tenta interpretar bytes que mapeiam pra tabela ASCII como letras e √†s vezes aparecem textos mesmo? Numa ROM de videogame isso n√£o funciona porque os c√≥digos das letras n√£o seguem a tabela ASCII. Mesmo entre jogos diferentes a posi√ß√£o das letras na ROM n√£o √© a mesma. Por isso em emuladores com debug como o Mesen e FCEUX podemos carregar nossa pr√≥pria tabela que mapeia c√≥digo das posi√ß√µes dos tiles pra letras, como essa na tela que √© um arquivo texto com extens√£o TBL. Assim podemos tentar reconhecer algum texto no meio do bin√°rio.</p>
<p>Vejam no espa√ßo PRG da ROM que n√£o d√° pra identificar nada. Mas carregando a tabela come√ßamos a reconhecer quais bytes s√£o textos. E com isso posso editar o texto, por exemplo trocando de MARIO pra FABIO. Resetamos o jogo e olha s√≥ como aparece meu nome. Podemos trocar todos os textos num cartucho e salvar o bin√°rio por cima, contanto que o texto novo caiba no mesmo espa√ßo usado pelo texto antigo. Esse √© o hacking mais simples de todos e que todo mundo que j√° brincou com bin√°rios j√° fez na vida. √â assim que muita gente traduziu cartuchos japoneses pra ingl√™s, por exemplo. Se tiver filhos pequenos imagino que eles v√£o gostar de ver os nomes deles nos jogos.</p>
<p>E podemos editar o bin√°rio n√£o s√≥ do texto como dos tiles. Por exemplo, existem programas como o Tile Layer Pro. Se abrirmos a ROM do Super Mario, no come√ßo vamos ver um monte de sujeira que s√£o bytes de programa, mas se descermos vamos encontrar os tiles do jogo. Pra enxergar melhor podemos mudar a paleta e rapidamente vamos come√ßar a reconhecer alguns, como os tiles que formam o personagem. Pra ver melhor, podemos arrastar os tiles pra esta outra janela e montar como um quebra cabe√ßa. O Mario grande √© formado por seis tiles. Na ROM tem a sequ√™ncia pra cada posi√ß√£o da anima√ß√£o, seja correndo ou pulando.</p>
<p>Podemos fazer mais, podemos editar cada tile e mudar o jogo completamente. √â um puta trampo editar tile a tile mas se tiver paci√™ncia fazendo isso eu poderia pegar os bits de tiles de um Zelda ou Megaman e mudar o Mario pra ser o Link, ou qualquer outro personagem que caiba em seis tiles ou menos. E s√≥ com as t√©cnicas eu mostrei aqui voc√™ poderia fazer um novo jogo usando um que j√° existe como base.</p>
<p>Sabe quem j√° fez isso? A Tectoy aqui no Brasil. Por causa deles n√≥s somos o √∫nico pa√≠s no mundo que ainda produz Master System novo at√© hoje. O Master System foi o concorrente do nintendinho nos anos 80. Tamb√©m √© um console de 8 bits mas no papel ele era tecnicamente superior. Em vez do MOS 6502 de 1.8 Mhz o Master System vinha com o Zilog Z80 que ia at√© 3.5 Mhz, quase o dobro de clock. Em vez de 2k de RAM e 2k de VRAM ele vinha com 8k de RAM e 16k de VRAM. Em vez de ser limitado a ter s√≥ 16 cores na tela, ele podia ter 32 cores, por isso jogos de Master System sempre parecem mais coloridos e vivos</p>
<p>Essa discuss√£o de especifica√ß√µes e jogos sempre foi uma constante nas rodas de gamers. Um Xbox One X √© tecnicamente mais poderoso que um PS4 Pro, mas o Playstation continua tendo alguns dos melhores jogos exclusivos como God of War ou Spiderman. Nos anos 80 n√£o era diferente. O Master System era mais poderoso mas as marcas que chamavam mais aten√ß√£o estavam no Nintendinho.</p>
<p>De qualquer forma o Master System conseguiu um p√∫blico cativo aqui no Brasil e a Tectoy come√ßou n√£o s√≥ a licenciar e distribuir jogos estrangeiros como come√ßou a lan√ßar jogos brasileiros. Um grande exemplo que eu lembro que me impressionou na √©poca foi o jogo da Turma da M√¥nica.</p>
<p>Esse jogo na realidade √© o Wonder Boy II com textos e sprites editados pra encaixar numa hist√≥ria da Turma da M√¥nica. Se nunca viram olhem lado a lado.</p>
<p>A Tectoy produziu v√°rios jogos usando essas t√©cnicas como Geraldinho, Sapo Xul√©, TV Colosso. Mas fazendo isso eles foram aprendendo como de fato programar no Master System e come√ßaram a produzir jogos mais elaborados. Por exemplo, um dos melhores jogos de Master System sem d√∫vida √© Castle of Illusion. Da√≠ a Tectoy pegou emprestado elementos desse jogo e fez um terceiro jogo na sequ√™ncia do tamb√©m excelente Land of Illusion, com fases novas e inimigos novos e chamou de Legend of Illusion. √â bem claro onde s√£o sprites dos jogos anteriores e quais s√£o sprites desenhados do zero. A parte art√≠stica ainda tava bem primitiva, mas j√° √© uma evolu√ß√£o.</p>
<p>Mas quando voc√™ treina e vai aprimorando as coisas melhoram. Por exemplo, eles come√ßaram a experimentar com a id√©ia de pegar jogos de Mega Drive, que √© um console bem mais poderoso que o Master System, pegar os sprites e elementos visuais e diminuir detalhes, diminuir cores, diminuir frames de anima√ß√£o pra tentar fazer caber no Master System. E fazendo isso eles de fato conseguiram alguns jogos interessantes. Mesmo a jogabilidade n√£o sendo nada boa, eu acho interessante pela tentativa. S√≥ no Brasil existem jogos como Street Fighter, Mortal Kombat, Ecco the Dolphin e A Pequena Sereia pra Master System.</p>
<p>Tem v√°rios videos no YouTube contando a hist√≥ria da Tectoy. Tem at√© v√°rios canais gringos descobrindo a Tectoy s√≥ agora e ficando impressionado de ver o Master System e Mega Drive sendo fabricados por aqui at√© hoje, recomendo darem uma olhada, √© uma parte da hist√≥ria da nossa ind√∫stria brasileira que infelizmente ficou parado nos anos 90 e n√£o conseguiu evoluir. Ali√°s, recentemente lan√ßaram um remake HD do Wonderboy II que ficou bem bacana e t√° em lojas como Steam. E claro, algu√©m fez um mod pra ele relembrando o jogo da Turma da M√¥nica. Ent√£o voc√™ tem uma vers√£o HD disso tamb√©m! Vale conferir s√≥ pela nostalgia se voc√™ jogou o original no come√ßo dos anos 90.</p>
<p>Bom, vamos voltar pro nintendinho. O que eu mostrei do c√≥digo do emulador √© s√≥ o come√ßo do esqueleto. Na verdade eu n√£o escrevi um emulador n√£o, esse foi um projeto que achei aleatoriamente no Github. Voc√™s podem baixar a vers√£o completa no link que vou deixar nas descri√ß√µes abaixo. E pra mostrar que ele funciona vamos compilar e executar.</p>
<p>(nes)</p>
<p>Um √∫ltimo insight que eu queria aproveitar pra falar √© sobre o PPU. Como expliquei ele era o equivalente aos nossos GPUs de hoje s√≥ que muito mais primitivo. Se havia um chip que trabalha incessantemente no nintendinho era o PPU, desenhando 60 quadros por segundo sem parar. Na verdade s√£o dois insights. Vamos l√°. Pra come√ßar eu disse que o MOS 6502 roda a meros 1.8 Mhz que √© milhares de vezes mais lento que qualquer CPU de hoje.</p>
<p>Antigamente jogos tentavam usar o m√°ximo que a CPU podia oferecer e o timing de tudo era atrelado ao clock do sistema. Hoje em dia n√£o fazemos isso, em vez de atrelar ao clock atrelamos a outras coisas como framerate que √© a taxa de quadros por segundo ou vsync que sincroniza com a frequ√™ncia de atualiza√ß√£o do monitor. Ou seja, se temos como alvo rodar o jogo a 60 quadros por segundo, vamos calcular tudo pra caber na faixa de 60 quadros por segundo. Mesmo se o clock aumentar ou diminuir, a refer√™ncia vai ser os quadros por segundo. Se a CPU for lenta demais vamos ser obrigados a cortar quadros. Se a CPU for r√°pida demais vamos dar pausas pra esperar. Estou simplificando, claro.</p>
<p>Mas jogos antigos n√£o tinham o luxo de esperar, cada clock contava. Por isso se programava em assembly pra ter controle absoluto do hardware. Da√≠ quando os CPUs evoluiram na gera√ß√£o seguinte e pularam de 1Mhz pra digamos 40Mhz os jogos ficaram r√°pidos demais. At√© por isso nos 386 de antigamente tinha um bot√£o Turbo. A id√©ia desse bot√£o era diminuir o clock do sistema pros programas n√£o rodarem r√°pidos demais. Se voc√™ tentar rodar um jogo dos anos 80 num PC moderno vai ver que ele roda r√°pido demais ao ponto de ser injog√°vel.</p>
<p>Um dos desafios mais dif√≠ceis nos emuladores de consoles antigos √© literalmente adicionar pausas em cada passo pro jogo rodar exatamente como seria antigamente, se n√£o tiver esse controle de pausas o jogo rodaria r√°pido demais. E nosso emulador precisa levar isso em conta. Por isso temos que editar o arquivo do CPU e adicionar outra informa√ß√£o importante: uma lista dizendo quantos ciclos cada instru√ß√£o consome. Lembra que falei que um Load, Adi√ß√£o e Store consomem em m√©dia uns 5 ciclos? N√£o pode ser aproximado assim, tem que ser a quantidade exata de ciclos. Ent√£o vamos adicionar a lista, onde cada posi√ß√£o √© o endere√ßo da instru√ß√£o como declaramos na estrutura table.</p>
<p>O segundo insight que falei tem a ver com timing de velocidade. O PPU √© ocupado demais, ele n√£o pode parar de desenhar na tela. Ele roda com clock 3 vezes mais r√°pido que a CPU e precisa de uma rotina pra sincronizar. A coordena√ß√£o entre CPU e PPU √© um assunto fascinante em si s√≥ mas a parte importante √© que a CPU n√£o pode interromper a PPU a qualquer momento. Ela vai estar escrevendo pixels na tela numa frequ√™ncia precisa e se voc√™ interromper, vai quebrar toda a renderiza√ß√£o.</p>
<p>Significa que do lado da CPU digamos que voc√™ detecte que um bot√£o foi pressionado no controle. Digamos que foi um bot√£o de salto. Voc√™ iria querer imediatamente mostrar isso na tela acionando a anima√ß√£o de salto do Mario por exemplo. Ent√£o voc√™ processa esse estado e envia o comando pro PPU atualizar o sprite do Mario. Mas isso vai quebrar a renderiza√ß√£o, ent√£o como faz?</p>
<p>A caracter√≠stica importante do PPU √© que ele escreve na tela uma linha horizontal de cada vez. Isso se chama ScanLine e √© derivado de como monitores de tubo funcionam. Se voc√™ nunca viu ele n√£o escreve pixels em qualquer coordenada. No fundo do tubo existe um canh√£o, que vai atirando el√©ctrons na tela de f√≥sforo na frente dele uma linha horizontal de cada vez e fazendo um zigue zague pra pr√≥xima linha. Diferente de LCDs modernos que tem uma quantidade fixa de linhas, monitores de tubo podem ter quantas linhas quiser, basta o canh√£o distanciar ou aproximar essas linhas. Por isso bons monitores de tubo tendem a ter imagens melhores do que LCDs. Recomendo ver esse video da Digital Foundry que explica sobre a qualidade esquecida dos CRTs e como eles ainda superam os LCDs.</p>
<p>De qualquer forma, o PPU do nintendinho vai desenhar 240 linhas vis√≠veis e depois vai entrar num per√≠odo entre as linhas 240 a 260 em que ele n√£o desenha nenhuma linha vis√≠vel. Isso se chama Vertical Blank ou Vblank. Isso acontece 60 vezes por segundo, uma vez depois de desenhar cada frame. √â nessa pequena janela de 20 ScanLines que o PPU tem a oportunidade de ser interrompido e receber ordens da CPU, por exemplo, dizendo o que tem que desenhar no frame seguinte.</p>
<p>De novo, se voc√™ √© de front-end, uma das boas pr√°ticas que deve ter aprendido, principalmente se usa frameworks como um React √© nunca escrever direto no navegador. Voc√™ acumula todas as modifica√ß√µes e escreve tudo de uma vez depois. E como voc√™ faz isso? Em vez de mandar ordens de desenhar direto na √°rvore de elementos HTML do navegador, o famoso DOM, voc√™ manda escrever numa c√≥pia desse DOM que s√≥ existe em mem√≥ria, o famoso Virtual DOM. Ent√£o se voc√™ modificou 50 elementos nesse VDOM, voc√™ n√£o precisou interromper o navegador 50 vezes. Voc√™ guarda essas modifica√ß√µes em mem√≥ria e s√≥ interrompe o navegador uma vez pra desenhar s√≥ o que mudou, uma vez s√≥.</p>
<p>E √© quase isso que se faz no nintendinho tamb√©m. A id√©ia de separar l√≥gica da apresenta√ß√£o n√£o √© novidade. √â assim que se programa desde pelo menos os anos 80. Ent√£o do lado da l√≥gica do jogo na CPU ele faz as modifica√ß√µes em RAM e durante o Vblank o PPU puxa essas modifica√ß√µes e avan√ßa pro pr√≥ximo frame, e com isso temos uma separa√ß√£o de responsabilidades.</p>
<p>Como cada jogo monta estruturas diferentes pra representar o que precisa mandar pra PPU. Mas um jogo que √© visualmente f√°cil de acompanhar √© o Super Mario Bros 3 porque ele mant√©m a estrutura completa da tela com cada elemento aberto na RAM. Se voc√™ procurar por memory map e o nome do jogo no Google facilmente vai achar a documenta√ß√£o que v√°rias pessoas gastaram horas garimpando e com isso sabemos que a partir do endere√ßo 0x6000 na RAM vai ter os dados de montagem de cada tela da fase.</p>
<p>Vamos abrir no Mesen e vou colocar lado a lado pra voc√™s verem. Se procurarmos na RAM depois do endere√ßo 0x6000 rapidamente vamos encontrar padr√µes que se assemelham √† tela que estamos, e na sequ√™ncia vai tendo todas as outras telas dessa fase. Olhem os c√≥digos internos de cada bloco dessa tela e veja como o c√≥digo muda quando eu modifico um objeto, por exemplo batendo nele.</p>
<p>E se voc√™ √© adepto de Mario Maker, esse √© o Mario Maker ra√≠z. Vamos olhar algumas telas pra frente. Por tentativa e erro sabemos que essas "arrobas" representam moedas. Vamos criar um monte .... e agora vamos at√© essa tela. ... Olha que bonito. E de novo vejam como cada vez que vou pegando as moedas o c√≥digo se modifica na RAM.</p>
<p>De novo usando a analogia com front-end, isso √© o equivalente a voc√™ dar um inspect no navegador e sair editando os elementos. E aproveitando que estamos no Mesen, vamos abrir primeiro o Super Mario de novo. E esses s√£o todos os tiles que tem no cartucho, somente um √∫nico bank de 16 kbytes. Pense que o jogo inteiro, que n√£o √© curto, √© desenhado somente com esses tiles. √â impressionante se considerar que antes dele voc√™ s√≥ tinha jogos n√≠vel pacman bem simples e eles conseguiram esticar pra m√∫ltiplas fases que parecem diferente mas que s√£o basicamente os mesmos tiles com paletas diferentes de cores.</p>
<p>Mas se abrirmos o Super Mario 3 de novo, que vem com o Mapper conhecido como MMC5, ele vai ter bem mais banks como eu expliquei. E olha s√≥ no visualizador de novo. Podemos ir explorando os diferentes banks que s√£o os conjuntos de tiles. E por isso o Super Mario 3 tem visuais bem mais elaborados e diferenciados de mundo pra mundo. N√£o √© s√≥ uma mudan√ßa de paleta de cores mas de diversidade de tiles. E no √∫ltimo olha como s√≥ a tela de entrada com t√≠tulo grande ocupa um bank quase inteiro. Por isso quando tem imagens bitmap grande que ocupam a tela inteira a gente sabe que √© um jogo caro porque literalmente ele t√° usando uma parte consider√°vel do chip s√≥ pra guardar essa uma imagem que s√≥ aparece uma vez.</p>
<p>Recentemente teve uma ressurg√™ncia de games independentes publicando nos Steam da vida que tentam emular o visual pixel art pra ter aquela vibe de jogo retro. Um bom exemplo disso √© o excelente jogo Celeste, considerado um dos melhores jogos de plataforma pra speedrun pela nuance nos controles e como ela recompensa quem consegue combinar timing com movimentos avan√ßados do jogo pra percorrer as fases. Outros exemplos s√£o os j√° classicos Meat Boy ou Shovel Knight tamb√©m. Mas o que esses jogos tem em comum √© que eles s√£o modernos mas s√≥ escolheram um estilo art√≠stico de pixel art pela est√©tica e n√£o porque foram obrigados a isso.</p>
<p>Entendam, jogos antigos n√£o s√£o pixel art porque o povo gostava do estilo mas sim porque a resolu√ß√£o da tela era de meros 256 pixels na horizontal por 240 pixels na vertical. Isso √© um quarto da resolu√ß√£o de um monitor full HD que tem 1080 pixels na vertical. Cabe literalmente 16 telas de nintendinho numa tela full HD. Mas agora voc√™ entende tamb√©m que n√£o √© s√≥ a resolu√ß√£o, todo o design do jogo, das fases, inimigos e outros elementos dependem muito do espa√ßo na ROM. Quanto mais ROM se adicionava no cartucho mais caro ele ficava. Por isso a maioria dos jogos se mantinha nos limites de 40 kilobytes que o Super Mario original usava. Em compara√ß√£o, a instala√ß√£o do jogo Celeste tem mais de 700 megabytes.</p>
<p>Existem v√°rios programadores hoje explorando programar no hardware limitado do nintendinho. Um grande exemplo √© o jogo Micro Mages da Morphcat Games. Dois anos atr√°s eles soltaram um mini document√°rio mostrando como as limita√ß√µes do console e do cartucho influenciaram as decis√µes de design do jogo. Eles se colocaram no desafio de fazer um jogo de verdade, bem feito, escrevendo em Assembly de 6502 e ainda suportando 4 jogadores simult√¢neos.</p>
<p>O jogo √© excepcional, eu paguei pra ter a ROM e recomendo que comprem tamb√©m, s√£o 10 d√≥lares bem gastos. A mec√¢nica √© muito simples, lembra um pouco a id√©ia do Celeste. √â um jogo vertical onde a tela vai subindo lentamente e voc√™ precisa alcan√ßar o fim da fase antes que a tela te alcance. E falando em fases, vale um par√™ntese pra explicar mais uma estrutura de dados que o nintendinho usava, os nametables. Em resumo hiper resumido, √© um espa√ßo na mem√≥ria do PPU que organiza o equivalente a 4 telas, duas em cada linha.</p>
<p>Se voc√™ est√° num Mario que √© plataforma horizontal, ele vai mantendo a pr√≥xima tela no espa√ßo √† direita. Olha como a mem√≥ria vai atualizando conforme vamos avan√ßando pelas telas.</p>
<p>Se for plataforma vertical como Kid Icarus ele mant√©m a pr√≥xima tela no espa√ßo pra cima e voc√™ pode trabalhar os modos desse namespace se precisar de algo mais complexo como num Mario 3 que √© horizontal mas quando voc√™ pega a folha pode voar vertical.</p>
<p>No caso do Micro Mages ele vai usar um modo semelhante ao do Kid Icarus. Jogando um pouco, veja lado a lado como o pr√≥ximo nivel vai se montando nesse espa√ßo de mem√≥ria de nametables.</p>
<p>No video da Morphcat ele come√ßa explicando o que eu j√° falei, que gr√°ficos s√£o divididos em duas tabelas CHR. Ele chama tiles de sprites mas √© a mesma coisa, eu chamo sprites os tiles que est√£o na tela neste momento. Ele continua repetindo que cada tile √© um quadrado de 8 por 8 pixels e que pode escolher at√© 3 cores da paleta. E que juntamos tiles pra formar o que ele chama de meta-sprites que √© o objeto completo. Continuando, ele explica que s√≥ d√° pra ter at√© 4 paletas de cores e que as cores s√£o reusadas pra outros objetos como inimigos porque n√£o d√° pra ter cores diferentes pra cada coisa, √© tudo as mesmas paletas.</p>
<p>Outra limita√ß√£o do PPU que eu n√£o mencionei ainda √© que ele s√≥ consegue desenhar 8 sprites por scanline. Como cada personagem √© formado por duas linhas de dois tiles cada, nesse exemplo vai ter 10 tiles por linha em vez do m√°ximo de 8. Se tiver mais que 8 os sprites seguintes simplesmente n√£o s√£o desenhados. Por isso um truque muito usado √© escolher 8 tiles dos 10 e desenhar num frame, da√≠ no pr√≥ximo frame voc√™ esconde 2 que foram desenhados no anterior e troca por 2 que ainda n√£o tinham sido desenhados, e vai permutando de frame a frame. Por isso muitos jogos de nintendinho parece que os personagens ficam piscando na tela. Isso acontece quando eles se movimentam e na mesma linha acaba ficando mais de 8 sprites.</p>
<p>Por causa dessas limita√ß√µes, a primeira decis√£o da Morphcat foi criar personagens que precisam s√≥ de um tile pra formar o sprite em vez de 4 ou mais. Al√©m de economizar em espa√ßo, isso tamb√©m evita o flicker, aquelas piscadas, porque vai ser mais dif√≠cil ter mais de 8 sprites por scanline. Falando s√≥ em espa√ßo, de volta √† tabela de tiles CHR na ROM, esse √© o espa√ßo ocupado por todos os tiles que formam as anima√ß√µes do Mario, que n√≥s j√° vimos antes. E agora o espa√ßo ocupado por todas as anima√ß√µes dos magos nesse novo jogo. Veja como economiza espa√ßo escolhendo fazer personagens menores que cabem num √∫nico tile. E n√£o s√≥ isso, tamb√©m conseguimos adicionar mais quadros na anima√ß√£o, tornando a movimenta√ß√£o mais fluida.</p>
<p>Outro desafio s√£o os chef√µes, que costumam ser sprites grand√µes. Por exemplo, esses s√£o todos os frames de anima√ß√£o de um dos chef√µes. O problema √© que se voc√™ tentar encaixar todas essas imagens no que restou do espa√ßo CHR, simplesmente n√£o vai caber. E isso √© s√≥ um chef√£o. Agora vem a parte onde a programa√ß√£o e o design precisam andar juntos, porque o designer tem que fazer um chef√£o cujos quadros podem ser divididos em partes, no caso tr√™s, que podem ser animados independentemente.</p>
<p>Olhando s√≥ os quadros que fazem a anima√ß√£o da cabe√ßa, dividimos em tiles, e vemos se tem repeti√ß√µes. E de cara voc√™ pode ver que a primeira metade em todos os tr√™s quadros √© igual, ent√£o s√≥ precisa armazenar uma vers√£o, que pode ser reusada em todos.</p>
<p>N√£o s√≥ isso, se um tile √© o espelho de outro tile, voc√™ guarda s√≥ uma vers√£o e pede pro nintendinho inverter horizontalmente, e assim pode economizar mais um pouco. E fazendo isso, s√≥ na cabe√ßa otimizamos de 16 tiles pra 4 que realmente precisam existir na ROM.</p>
<p>Pra parte do meio, fazemos a mesma coisa: procuramos todos os tiles repetidos, todos que podem ser invertidos e diminu√≠mos mais ainda.</p>
<p>E a √∫ltima parte tem 5 anima√ß√µes mas de cara as duas √∫ltimas s√£o invers√µes das duas primeiras. E fazendo todas as mesmas redu√ß√µes, removendo tudo que √© repetido, compare os tiles que sobraram com os que originalmente eram necess√°rios sem otimizar.</p>
<p>O video deles continua mostrando como aplicaram outras t√©cnicas pra reduzir ainda mais a quantidade de mem√≥ria necess√°ria pra montar as fases. Mas eu vou pular pra n√£o ficar extenso demais, por isso recomendo que assistam e tamb√©m comprem o jogo.</p>
<p>Falando em programar seus pr√≥prios jogos, como voc√™ faz isso? Simples, se pesquisar no Wiki da Nesdev vai encontrar sobre ferramentas, tem v√°rios f√≥runs ainda ativos onde o povo troca dicas e informa√ß√µes sobre as melhores t√©cnicas e ferramentas, mas o mais b√°sico √© o cc65 que vem com o montador ca65 e o disassembler da65. E se procurar num Github vai encontrar v√°rios exemplos, de hello world a joguinhos completos feitos do zero como o Micro Mages. Se voc√™ j√° pensou em programar games e n√£o quer ser s√≥ mais um mero clonador de Flappy Bird, programar em hardware restrito como um nintendinho √© um excelente exerc√≠cio pra aprender todos os fundamentos de um bom design de games.</p>
<p>Por exemplo, baixei este projetinho que faz todo o setup do ambiente, carrega o m√≠nimo de tiles e tudo mais pra ter fontes e com isso consigo fazer um hello world da vida rapidamente em C. E sim, √© poss√≠vel programar em C e compilar com o cc65 pra bin√°rio de 6502 espec√≠fico de nintendo. A desvantagem de programar em C √© que ele vai gerar um bin√°rio menos otimizado do que um bom programador faria na unha direto em assembly. Por outro lado, como estamos em ambiente emulado voc√™ sempre pode mexer no emulador pra ter uma CPU mais r√°pido do que o nintendinho original e quantos banks de ROM quiser.</p>
<p>Ali√°s, sobre o hello world, considere o seguinte: o nintendinho n√£o tem um sistema operacional, sequer vem com fontes numa ROM, o jogo tem que fazer tudo, ent√£o pra fazer um hello world, voc√™ precisa primeiro armazenar suas pr√≥prias fontes no espa√ßo CHR da ROM. S√≥ depois pode escrever alguma coisa.</p>
<p>Falando nisso vale a pena mostrar como subir um pouquinho o n√≠vel da linguagem pra n√£o ficar t√£o tedioso fazer s√≥ assembly puro. N√£o √© um compilador ainda, t√° longe disso, mas muitos assemblers tem capacidade pra macros. Pra quem n√£o sabe, macro √© como um template. Um procesador de Markdown √© tipo um macro de HTML. Quando eu digito asterisco o processador vai pegar o texto seguinte e colocar entre as tags de bold por exemplo. Macro √© uma forma de reduzir copy e paste de trechos de c√≥digo.</p>
<p>O ca65 que √© o assembler mais recomendado pra programar pro nintendinho j√° vem com v√°rios macros que adicionam algumas constru√ß√µes mais modernas como ifs, whiles e outras coisas, assim voc√™ consegue ter mais dicas visuais do que cada trecho faz em vez de ver s√≥ um lingui√ß√£o de instru√ß√µes. Some isso a subrotinas com JSR que mostrei no video anterior e √© poss√≠vel programar sem ficar completamente doido no processo. Mas pense assim: √© assim que se programava games de verdade. O grande lance de programar em consoles √© tirar o m√°ximo que o hardware consegue oferecer.</p>
<p>Outra coisa interessante. Hoje em dia n√£o existe mais o c√≥digo fonte da maioria esmagadora dos games. Muitas empresas da √©poca at√© faliram e muito material se perdeu. Mas isso n√£o tem problema. Voc√™ sempre consegue reabrir o c√≥digo a partir do bin√°rio. Pra isso serve a ferramenta da65 que vem no mesmo pacote. Voc√™ pode fazer o desassembly e voltar aos mnem√¥nicos. Obviamente n√£o vai ter o nome correto das subrotinas, labels, constantes e vari√°veis. Mas se voc√™ tiver experi√™ncia com o hardware vai saber por exemplo que se tiver alguma coisa mexendo com o endere√ßo a partir de 0x8000 est√° acessando a ROM, se mexer com o endere√ßo 0x4016 ou 0x4017 est√° falando com os controles.</p>
<p>Da√≠ voc√™ pode fazer a engenharia reversa que √© adicionando as etiquetas e nomes das coisas mais √≥bvias primeiro e fazer o caminho inverso. Ah, se esse trecho mexe com o endere√ßo 0x4016 deve ser o trecho que decide o que fazer quando aperta um bot√£o. Al√©m disso voc√™ pode fazer tracing, visualizar o que acontece em cada registrador e na mem√≥ria a cada instru√ß√£o pra determinar do que se trata cada subrotina. √â super trabalhoso mas fazendo isso voc√™ consegue encontrar praticamente tudo. Diversos jogos j√° foram mapeados assim.</p>
<p>E de fato, se procurar no Github voc√™ vai achar um disassembly do Super Mario praticamente completo com todos os nomes de subrotinas, etiquetas e constantes. √â o mais pr√≥ximo que se chegou do c√≥digo fonte original. E em cima disso voc√™ pode modificar o jogo como quiser no n√≠vel do c√≥digo em vez de se limitar a s√≥ modificar os bytes no n√≠vel da ROM como fizemos com textos e tiles. Podemos adicionar tiles novos ou fazer textos mais longos e reprogramar a l√≥gica porque o assembler vai conseguir recalcular todos os endere√ßos corretamente e gerar um novo bin√°rio que funciona.</p>
<p>Finalmente, vou completar a maior tangente que fiz at√© hoje. Voc√™s v√£o se lembrar que o epis√≥dio anterior come√ßou s√≥ porque eu vi um video falando sobre o Game Genie. Como expliquei antes, Game Genie √© um hardware que fica entre o cartucho e o console. E agora sabemos que o cartucho responde a uma faixa de endere√ßos bem espec√≠fico entre $8000 e $FFFF. Tamb√©m sabemos que endere√ßos que a CPU pede n√£o correspondem √† localiza√ß√£o exata nos cartuchos por causa do sistema de mappers e bank switching.</p>
<p>Existem duas formas de adicionar cheats, ou trapa√ßas nos jogos. Uma delas √© alterando o valor carregado na mem√≥ria RAM e a outra √© alterando direto o bin√°rio na ROM. Com bastante paci√™ncia voc√™ consegue visualizar o conte√∫do da RAM usando emuladores como o FCEUX e o Mesen, gravar dumps da mem√≥ria entre uma parte do jogo e outro e comparar os bits pra ver o que mudou. Por exemplo, gravar a RAM antes de morrer e depois de morrer pra ver qual byte diminuiu e ele √© um candidato pra ser o local na mem√≥ria que representa quantas vidas voc√™ tem, da√≠ voc√™ pode testar esse valor.</p>
<p>Com tantas d√©cadas de gente escovando bits, existem bancos de dados inteiros com diversos cheats pra cada jogo. Voc√™ facilmente consegue encontrar c√≥digo pra tudo. Num emulador como o RetroArch tem at√© funcionalidades pra sincronizar com esses bancos de dados da√≠ voc√™ nem precisa digitar os c√≥digos manualmente. S√≥ escolher o jogo, selecionar em cheats, carregar e j√° era.</p>
<p>Resumindo o video do canal Retro Game Mechanics Explained o que o hardware do Game Genie faz √© receber um endere√ßo de 16-bits e um ou dois valores de 8 bits cada. Isso forma c√≥digos de 6 ou de 8 letras. Quando o c√≥digo tem 6 letras √© f√°cil porque os primeiros 4 d√≠gitos representam o endere√ßo na RAM e os dois √∫ltimos digitos representam o valor que o Game Genie vai devolver e pronto. Quando estamos falando de jogos usando o Mapper mais simples, como num Super Mario original que s√≥ suporta ROMs com 40 kilobytes, isso √© tudo que precisamos.</p>
<p>Agora que voc√™ entende bank switching, sabe que no mesmo endere√ßo da RAM pode estar apontando dados em banks diferentes da ROM. Depende de qual bank t√° apontando no momento. Ent√£o o Game Genie n√£o pode responder com um valor fixo toda hora, s√≥ quando um determinado bank t√° selecionado. Pra isso serve o c√≥digo de 8 digitos. De novo, os primeiros 4 formam o endere√ßo na RAM. Agora os dois d√≠gitos seguintes representam qual √© o valor que esperamos encontrar na RAM, ou seja, o valor que ele carregou do bank. Se for diferente do que passamos √© porque o console t√° olhando um bank diferente do que queremos. Mas quando o valor voltar igual, √© porque ele mudou pro bank que queremos, e a√≠ devolvemos o valor fixo que t√° no ultimos dois d√≠gitos do c√≥digo.</p>
<p>A forma como o Game Genie monta os c√≥digos √© s√≥ um embaralhamento arbitr√°rio que ele faz sei l√° porque, talvez s√≥ pra deixar o c√≥digo um pouco mais leg√≠vel. √â s√≥ uma obfusca√ß√£o simples. Pra isso primeiro voc√™ pega os bits do endere√ßo e dos dois valores, da√≠ embaralha os bits pra outras posi√ß√µes, e no fim substitui cada bloco de 4 bits por uma letra de acordo com uma tabela arbitr√°ria. Pra cada console tem uma regra de embaralhamento e tabela de mapeamento de letras diferentes.</p>
<p>Eu fiz um programinha bem besta na linguagem Crystal que pega o c√≥digo do Game Genie, traduz de volta em bits, desembaralha os bits e devolve o endere√ßo e os valores. Eu fiz em Crystal s√≥ porque eu quis, nenhuma raz√£o especial, podia ser em qualquer linguagem. Vou deixar o link pra esse c√≥digo nas descri√ß√µes abaixo. Talvez eu termine de fazer o desembaralhamento das vers√µes de game genie pros outros videogames mas eu queria um execut√°vel simples pro meu teste.</p>
<p>Eu fiz algumas coisas do jeito menos otimizado, estilo "o que funciona primeiro", ent√£o n√£o xinguem. Pelo menos tem testes unit√°rios direitinho. Veja esse por exemplo, eu garanto que eu passo um c√≥digo de Game Genie e ele vai gerar o bin√°rio que eu quero. Da√≠ no outro spec eu garanto que dado esse lingui√ß√£o de bits vai gerar a representa√ß√£o em hexadecimal direitinho tamb√©m.</p>
<p>O c√≥digo em si √© muito simples. Ele come√ßa pegando o c√≥digo de 6 ou 8 letras do game genie, processa letra a letra e troca pela representa√ß√£o bin√°ria. Eu n√£o estou lidando com o n√∫mero bin√°rio e sim com a representa√ß√£o em texto mesmo pra ficar mais f√°cil. Depois de montar esse bin√°rio, o pr√≥ximo passo √© desembaralhar, e isso √© arbitr√°rio do game genie, s√≥ trocar bits de posi√ß√£o. Finalmente, com os bits rearranjados, fa√ßo um outro loop besta pegando de 4 em 4 bits e transformando em hexadecimal.</p>
<p>Voc√™s v√£o notar que eu fiz de um jeito meio tosquinho aqui criando um array pra mapear cada conjunto de bits no hexadecimal em vez de converter a string num n√∫mero e depois usar um formatador pra hexa, mas foi mais porque eu n√£o achei f√°cil o jeito de fazer isso em Crystal ainda. Quando descobrir eu mudo. Mas pros meus prop√≥sitos esse c√≥digo t√° suficiente. Com isso eu posso compilar um bin√°rio e ... pronto, posso chamar o bin√°rio, passar o c√≥digo de game genie e ele devolve o hexadecimal certo.</p>
<p>O pr√≥ximo passo foi mexer no emulador feito em Go. A grande maioria dos emuladores mais maduros e populares tem suporte a c√≥digos de game genie. Mas esse emulador mais simples n√£o tinha, por isso achei que seria um exerc√≠cio interessante. Pra come√ßar eu resolvi modificar o arquivo do console adicionando uma estrutura chamada Cheat que vai ter s√≥ dois elementos, o valor de condi√ß√£o pra comparar com o que t√° no bank da ROM selecionado nesse instante, e o valor trapaceado que eu quero devolver. Da√≠ eu adiciono na estrutura do console uma nova estrutura, um Map de Cheats. Map √© o que algumas linguagens chamam de dicion√°rio ou de hash. √â uma lista que vai mapear um n√∫mero inteiro, que no caso, √© o endere√ßo com uma inst√¢ncia da estrutura de Cheat.</p>
<p>Agora precisamos ler os cheats de algum lugar. No caso escolhi ler de um arquivo. Eu n√£o estou mostrando, mas estou seguindo o padr√£o que esse emulador j√° fazia pra fazer saves dos jogos, criando um hash md5 do bin√°rio. O nome do arquivo que eu vou buscar √© o hash md5 do Super Mario numa pasta .nes/cheats. Essa fun√ß√£o readCheats recebe o caminho pra esse arquivo e s√≥ vai lendo linha a linha e gravando numa lista. Assim podemos ter m√∫ltiplos arquivos pra com c√≥digos espec√≠ficos de cada jogo que queremos.</p>
<p>A fun√ß√£o seguinte vai interpretar essa lista. A fun√ß√£o LoadCheats vai usar a readCheats acima passando o caminho do arquivo e recebendo a lista que ele ler. Da√≠ eu passo um caminho fixo mesmo por enquanto, pro execut√°vel daquele programinha que eu fiz em Crystal. Ele vai passar os c√≥digos pra esse programinha pra decodificar o endere√ßo e valores.</p>
<p>Com o que ele devolver, checo se √© um c√≥digo de 6 ou 8 digitos, e isso serve pra preencher ou n√£o aquele campo de condi√ß√£o na estrutura de Cheat. Feito isso associamos o endere√ßo devolvido com a estrutura de Cheat e jogamos no dicion√°rio na estrutura do Console. Com isso o console t√° ciente dos c√≥digos.</p>
<p>Pra de fato aplicar o cheat o lugar mais √≥bvio pra procurar √© a estrutura de Memory, lembram dele? √â nesse arquivo que tem a l√≥gica pra escolher qual mapper o cartucho carregado precisa. Mas ele abstrai os mappers e a gente n√£o precisa se preocupar. Os Mappers v√£o se encarregar de ler da ROM nos banks corretos. Ent√£o o que vamos fazer √©, em vez de devolver o valor lido, vamos gravar temporariamente numa vari√°vel e passar pra uma nova fun√ß√£o chamada replaceWithCheat.</p>
<p>Essa fun√ß√£o recebe o endere√ßo consultado e o valor devolvido. Agora acessamos o dicion√°rio de Cheats que t√° na inst√¢ncia do Console e procuramos por esse endere√ßo. Se n√£o achar nada, devolve o valor real original. Caso encontre ele checa se precisa comparar com a condi√ß√£o do Cheat.</p>
<p>Se n√£o tiver condi√ß√£o ou se a condi√ß√£o bate com o valor real, ent√£o ele devolve o valor falsificado. E pronto, √© s√≥ isso que precisa pra implementar um game genie num emulador. Com isso o console vai receber o valor falsificado em vez do valor real e nosso Super Mario vai come√ßar com mais vida. Podemos testar isso.</p>
<p>Veja o arquivo de cheats com o c√≥digo. Agora executamos o emulador passando a ROM do jogo, esperamos carregar e olha s√≥, 9 vidas!!</p>
<p>Mas digamos que a gente √© ruim em Super Mario e o tempo sempre acaba, quero que comece com 900 segundos em vez de s√≥ 400 e se procurar no Google descubro que o c√≥digo pra isso √© VGYOKK, ent√£o vamos editar o arquivo de trapa√ßas e adicionar o c√≥digo. Reiniciamos o emulador e ... veja s√≥ que bacana, 9 vidas e 900 segundos pra terminar a fase.</p>
<p>Mas digamos que a gente √© t√£o ruim, mas t√£o ruim que morre toda hora. Malditos Goombas! Mas n√£o se preocupem, existe um c√≥digo pra isso. Vamos editar de novo o arquivo e adicionar SSASSA. Agora vamos reiniciar o emulador e corremos de cara pra um Goomba. E olha s√≥, invencibilidade!!</p>
<p>Voc√™s v√£o notar no terminal que toda vez que eu encosto num inimigo o programa busca o endere√ßo 0xD88D pra checar se √© pra perder vida ou n√£o, da√≠ se devolver 0xD5 ele sabe que √© invenc√≠vel. E √© assim que trapaceamos pra chegar at√© o final f√°cil! E com isso finalmente consegui fechar o assunto que comecei no video anterior, fazer meu pr√≥prio Game Genie de Nintendinho. Com tudo que expliquei desde o v√≠deo anterior agora voc√™s entendem exatamente como tudo funciona.</p>
<p>E pra finalizar o epis√≥dio de hoje quero mostrar como voc√™s v√£o ter uma no√ß√£o melhor pra entender videos de outros canais tamb√©m. No pr√≥prio canal do Retro Game Mechanics Explained, alguns dos videos mais divertidos √© a explica√ß√£o de diversos bugs que esses jogos tem, e como podemos tirar vantagem disso. Uma das categorias de gamers mais escovadores de bits s√£o os speedrunners. S√£o jogadores que competem pra bater o recorde de quem acaba o jogo no menor tempo. Tem v√°rias sub-categorias. Uma das mais divertidas √© quando eles encontram bugs que permitem, por exemplo, saltar todas as fases e ir direto pro final.</p>
<p>Antes de falar desse bug preciso falar de uma √∫ltima ferramenta que emuladores mais avan√ßados como o FCEUX tem, se chama TAS ou Tool Assisted Speedrun. Lembram no nosso c√≥digo em Go que eu associo controles na estrutura de console? Obviamente n√≥s conseguimos ler o que vem do controle pra poder codificar o que cada bot√£o apertado vai fazer no jogo. E naturalmente eu posso fazer o que quiser com esses dados, inclusive salvar num arquivo. Mais do que isso, como eu controlo a PPU tamb√©m consigo saber exatamente em que frame cada bot√£o foi apertado.</p>
<p>Ent√£o eu tamb√©m consigo ler esse tal arquivo que diz em que frame foi apertado qual bot√£o e com isso podemos dar replay no jogo inteiro repetindo exatamente tudo que que foi apertado com precis√£o de 1 frame. E √© exatamente assim que esses jogos s√£o arquivados em sites como o tasvideos.org, que mant√©m registros de todos os recordes. E voc√™ pode baixar o arquivo formato .fm2 ou .fm3 que cont√©m exatamente essa sequ√™ncia, rodar no seu emulador e assistir o speedrun exatamente como a outra pessoa jogou.</p>
<p>Ent√£o eu vou abrir o FCEUX, carregar a ROM do Super Mario 3, abrir o TAS Editor e carregar o arquivo .fm2 que baixei do site tasvideos.</p>
<p>Pronto, agora √© s√≥ despausar e assistir. Vou pular as primeiras fases porque ele usa outros truques conhecidos pra ir pulando de warp zone em warp zone at√© chegar no mundo 7. Nesse ponto a maioria dos speedrunners ia pro Dark World normalmente, mas nessa corrida eles v√£o pelo Pipe World porque √© de l√° que d√° pra acionar o bug. Assistam primeiro.</p>
<p>(glitch run)</p>
<p>Foda n√©, voc√™s n√£o entenderam nada eu imagino, mas deu pra ver que eles fazem uma sequ√™ncia bem absurda de coisas no Pipe World, da√≠ come√ßa tudo a descer pra um monte de sujeira de tiles e de repente ele chega na princesa direto. Agora que voc√™s tem uma id√©ia de como as coisas funcionam, d√° pra entender que o bug aciona alguma coisa que faz a tela descer por um peda√ßo de RAM com bytes aleat√≥rios que ele manda pro PPU que mapeia os tiles correspondentes, montando uma fase toda bagun√ßada e com comportamento incerto. E em algum momento d√° um JUMP. O truque √© simples, vamos usar a posi√ß√£o dos sprites na RAM pra montar um assembly em tempo real e dar um jeito de executar.</p>
<p>O c√≥digo em si que precisa ser escrito √© JSR 0x8FE3. Se conseguir fazer o jump esse √© o endere√ßo pra subrotina que inicia a sequ√™ncia final da princesa. Ent√£o precisamos de 3 bytes consecutivos num lugar especial na RAM, os bytes sao 0x20 que √© o JSR, e depois 0xE3 e 0x8F que √© o endere√ßo com os bytes invertidos por causa de little endian, que voc√™s j√° sabem como funciona.</p>
<p>A posi√ß√£o X dos inimigos, especialmente dos koopa troopers ficam sempre no mesmo lugar e n√£o apagam mesmo quando o sprite some da tela. Por isso esses bytes s√£o bons candidatos pra usar. Mas n√£o adianta sair matando qualquer koopa. Precisamos que eles estejam na posi√ß√£o correta nessa lista e tamb√©m que estejam numa posi√ß√£o X espec√≠fica. Pra isso precisamos tentar fazer com que eles apare√ßam numa determinada ordem primeiro. A l√≥gica √© que novos sprites sempre v√£o aparecer primeiro na posi√ß√£o mais alta livre da lista primeiro. Ent√£o usamos essa informa√ß√£o pra fazer eles aparecerem numa ordem em particular.</p>
<p>Ao matar essa tartaruga e ir pro cano enquanto ela ainda est√° na tela, podemos for√ßar as plantas piranha pra aparecer nos slots 2 at√© 4 e o pr√≥ximo koopa no slot 5.</p>
<p>Matamos as plantas pra elas n√£o reaparecerem mais tarde quando voltarmos pra essa parte.</p>
<p>Agora o koopa entre os blocos de interroga√ß√£o vai estar no slot 4 e o parakoopa no slot 3. Pegamos a casca dessa tartaruga e matamos jogando ele no bloco. Isso fixa o byte na posi√ß√£o fixa 0xE3 que precisamos.</p>
<p>Da√≠ ficamos exatamente nessa posi√ß√£o em cima do cano e damos uma rabada no parakoopa quando ele estiver exatamente alinhado com o topo do outro cano pra garantir que a casca aterrisse na posi√ß√£o X hexadecimal 0x20, e com isso temos o byte que representa o jump. Agora vamos pra baixo, agarramos a casca desse koopa e voltamos ao comeco do n√≠vel.</p>
<p>Nesse ponto precisamos realizar o bug do cano apertando pra baixo no controle ao mesmo tempo que faz um clip na parede no canto desse cano. √Äs vezes o Mario consegue fazer um clip numa parede, tipo passar por ela, se estiver r√°pido o suficiente e bater bem na beira do grid de 16 pixels, √© um movimento bem preciso e √†s vezes precisa fazer v√°rias vezes pra acertar. Nessa sequ√™ncia n√£o tem tanto problema se de vez em quando pisar na casca pra tartaruga n√£o acordar.</p>
<p>Uma vez entrando no cano inicia uma sequ√™ncia de bugs porque n√£o tava programado pra ter como ele entrar no cano nesse ponto, dai vai descendo por todo esse lixo aleat√≥rio que t√° na mem√≥ria. O PPU vai simplesmente mapeando o lixo que vai recebendo com os tiles na tabela CHR e mostrando na tela. Por isso fica essa bagun√ßa visual.</p>
<p>No final tem que pular com muito cuidado com a casca e alinhar com o fundo bem nessa posi√ß√£o. Tem um detalhezinho que se notar que esse bloco de m√∫sica estiver parcialmente cortado, talvez precise mover o Mario um pixel pra direita pra compensar a posi√ß√£o da camera. Deixamos o koopa reaparecer nas nossas m√£os e desaparecer no fundo da tela, e essa posi√ß√£o onde ele desaparece nos d√° o √∫ltimo byte que precis√°vamos, valor 0x8F. Finalmente ca√≠mos aqui e pulamos pra ativar a instru√ß√£o. E se tudo foi configurado exatamente como mostrado aqui, vamos pular direto pra princesa e terminar o jogo.</p>
<p>Pra entender o que aconteceu vamos usar tudo que aprendemos at√© agora. Essa fase vertical √© mapeada entre os endere√ßos 0x6000 e 0x6EFF, que √© suficiente pra 16 telas. Mas aquele cano que entramos depois de clipar pela parede manda o Mario pra tela 19 que obviamente n√£o existe. Ent√£o acontece um transbordamento, um overflow da mem√≥ria e come√ßamos a acessar √°reas da RAM que n√£o era pra acessar.</p>
<p>E pra piorar, al√©m de visualmente aparecer essa zona, a rotina de desenho falha e o que estamos vendo pode n√£o estar de fato l√°, por isso o Mario consegue subir numa plataforma invis√≠vel. A coincid√™ncia √© que o final desse cano deixa o Mario do lado de um bloco de nota invis√≠vel e √© batendo nesse bloco que ativa os bytes de Jump que configuramos.</p>
<p>Quando batemos num bloco de musica o tile √© temporariamente removido e outra vers√£o do sprite aparece pra fazer a anima√ß√£o. E claro, o √≠ndice nos dados da tabela de fase t√° todo zoado quando procura por esse tile e ele pega o endere√ßo 0x9C70 pra atualizar, que n√£o √© nem de longe perto da tabela de dados. Pior esse endere√ßo simplesmente n√£o existe na RAM.</p>
<p>Recapitulando o que j√° vimos sobre os endere√ßos que nintendinho entende, temos a RAM entre 0x0000 e 0x1FFF e temos Work RAM entre os endere√ßos 0x6000 e 0x7FFF e j√° sabemos que de 0x8000 at√© 0xFFFF √© a regi√£o reservada pra ROM, ou seja, pro cartucho. Ent√£o aquele √≠ndice errado do bloco de musica tenta escrever na ROM. Mais do que isso, esse endere√ßo na verdade fala com o Mapper do cartucho. E voc√™ sabe o que √© um Mapper.</p>
<p>Por acaso quando tentamos escrever nesse endere√ßo 0x9C70, √© o mesmo que dizer pro Mapper fazer uma troca de banco, pra apontar pra outros bancos da ROM. Recapitulando, j√° sabemos que entre os endere√ßos 0x8000 e 0xFFFF s√≥ cabe 32 kilobytes de dados, mas a ROM de programa do Super Mario 3 tem 256 kilobytes. Obviamente n√£o cabe e por isso durante o jogo ele vai pedindo pro Mapper ir trocando os bancos pra apontar pra outras regi√µes da ROM.</p>
<p>Ent√£o esse trecho t√° fazendo seu trabalho feliz e contente, achando que t√° atualizando um tile na tela pro bloco de musica, mas em vez disso quando executa a instru√ß√£o no endere√ßo 0xDD1A, a ROM de 0xA000 a 0xDFFF √© trocado pelo mapper do nada. Ele literalmente atira no pr√≥prio p√© e as pr√≥ximas instru√ß√µes foram trocadas pelo que t√° no novo banco que o Mapper trocou.</p>
<p>O apontador de pilha nesse momento da execu√ß√£o √© 0xFD, que sabemos que quer dizer que a pilha t√° quase vazia, lembra do video passado e do c√≥digo de Reset da CPU que fizemos antes? Lembra que a instru√ß√£o RTS vai retornar pro √∫ltimo endere√ßo que estiver na pilha? E por acaso na pilha tem s√≥ um endere√ßo nesse momento. E de fato essas instru√ß√µes novas que vieram na troca do bank pelo Mapper, ele continua executando e uma hora bate num RTS fazendo ele pular pro endere√ßo 0x8F4D.</p>
<p>Agora ca√≠mos no meio de uma nova rotina com uma pilha vazia, coisa que ele n√£o esperava. Da√≠ ele continua executando e uma hora vai bater num RTS, vai olhar pra pilha pra saber pra onde retornar. Mas a pilha t√° vazia ent√£o quando isso acontece o ponteiro faz um wrap, ele circula como se a pilha estivesse totalmente cheia, lembra de quando falei de stack overflow no video anterior?</p>
<p>Lembrando que a pilha fica entre os endere√ßos 0x0100 e 0x01FF, mas praticamente nunca a pilha enche totalmente ent√£o alguns programas acabam usando o topo da pilha pra outra coisa e no caso o jogo mant√©m informa√ß√£o da fase em 0x0100. L√° vai ter o valor 0xC0 se forem fases horizontais e 0x80 em fases verticais. E como o ponteiro circulou pro topo da pilha ele pega o valor que t√° l√°, subtrai 1 e retorna o endere√ßo 0x0081.</p>
<p>Beleza, ent√£o o RTS vai pular pra 0x0081 e isso √© endere√ßo da RAM que tem um monte de dados vol√°teis sobre as propriedades da fase. Por exemplo em 0x007E a 0x0086 tem propriedades sobre os sprites carregados nesse momento, tipo o timer de quando as plantas piranha tem que aparecer dos canos, ou como os parakoopas voam. Dos endere√ßos 0x0087 a 0x008F tem o high byte da posi√ß√£o Y de cada sprite, que √© o n√∫mero da tela onde eles est√£o.</p>
<p>Agora chegamos onde quer√≠amos porque dos endere√ßos 0x0090 a 0x0098 est√£o os low bytes da posi√ß√£o X de cada sprite na tela, que s√£o as posi√ß√µes que viemos manipulando no come√ßo e configuramos o JUMP. Os bytes antes disse s√£o dados, mas o processador n√£o sabe disso e tenta executar como se fossem instru√ß√µes. Por coincid√™ncia nenhuma das tentativas de executar esses dados termina num crash e ele consegue chegar at√© nosso jump. Como esses dados anteriores podem ser qualquer coisa que representa os tais elementos na tela que falei, poderiam ser bytes que representam instru√ß√µes que crasheiam, ent√£o essa sequ√™ncia toda que fizemos n√£o √© garantido que funciona sempre, mas funciona vezes o suficiente.</p>
<p>Chegando no nosso JSR 0x8FE3 ele pula pra um programa que fica num bank que nunca √© trocado pelo mapper ent√£o garantidamente sempre vai estar l√° e √© a rotina pra carregar o quarto da princesa.</p>
<p>Pra fechar, a sequ√™ncia pra montar a instru√ß√£o de jump pode ser feita de v√°rias formas contanto que a posi√ß√£o X dos inimigos certos entre na sequ√™ncia correta nos slots da mem√≥ria. Esse √© o recorde mundial usando esse bug do MitchFlowerPower onde ele termina o jogo em 3 minutos e 9 segundos. Ele mesmo jogou manualmente e gravou seus comandos.</p>
<p>E com tudo isso dito, finalmente chegamos ao final do epis√≥dio! Tudo que eu queria era explicar como o Game Genie funciona, mas pra realmente entender era necess√°rio entender cada componente de como um computador funciona. Com isso eu espero que se voc√™ √© iniciante tenha conseguido ter uma vis√£o um pouco mais abrangente do que significa fazer um hardware funcionar.</p>
<p>Pra mim isso √© programa√ß√£o. Programa√ß√£o nunca foi sobre seguir receitas e procedimentos prontos e sim encontrar um cen√°rio de restri√ß√£o e com conhecimento de verdade usar as ferramentas dispon√≠veis pra conseguir solu√ß√µes criativas. Nenhum livro, nenhum curso, nenhum tutorial jamais vai ensinar essas coisas. S√≥ quando voc√™ encara problemas dif√≠ceis √© que conhecimento de verdade come√ßa a aparecer. Eu tenho certeza que voc√™s nunca imaginaram que tinha tanta coisa que podia ser dito sobre um videogame obsoleto dos anos 80.</p>
<p>Se voc√™ ficou empolgado pra escrever seu pr√≥prio emulador recomendo que acompanhem outro canal, o do One Lone Coder que est√° desenvolvendo um emulador de NES em C++ e explicando passo a passo no seu canal. Vou deixar o link nas descri√ß√µes abaixo. O pr√≥prio canal do Retro Game Mechanics Explained na realidade tem videos detalhados explicando o funcionamento do Super Nintendo. Como funcionam os gr√°ficos e cores, como funciona a mem√≥ria, como funciona o lend√°rio Mode 7. Tem bastante coisa pra aprender.</p>
<p>Se voc√™s pensam que eu acabei todos os assuntos, t√£o enganados. Descer nesse buraco de coelho me levou a rever um monte de coisas do passado em rela√ß√£o a emuladores e estou pensando em fazer um epis√≥dio mais leve do que esses pra explicar o ecossistema atual de emuladores. Pra variar eu vou descer mais no detalhe em alguns deles ent√£o aguardem pelo pr√≥ximo. Como v√°rios assuntos eu tive que resumir ou mesmo pular pra n√£o ficar confuso demais, se voc√™ tamb√©m √© entusiata desses assuntos, n√£o deixem de complementar nos coment√°rios abaixo. Se curtiram o video mandem um joinha, assinem o canal e cliquem no sininho. E principalmente ajudem o canal compartilhando os videos com seus amigos. A gente se v√™ na pr√≥xima, at√© mais!</p>
<p>Links:</p>
<ul>
  <li>Super Mario Bros. 3 - Wrong Warp (https://www.youtube.com/watch?v=fxZuzos7Auk)</li>
  <li>A Comprehensive Super Mario Bros. Disassembly (https://gist.github.com/1wErt3r/4048722)</li>
  <li>Lembra deles? Confira jogos brasileiros do Master System lan√ßados pela Tectoy! (https://blogtectoy.com.br/lembra-deles-todos-jogos-brasileiros-do-master-system-lancados-pela-tectoy/)</li>
  <li>Free NES assembler (https://bisqwit.iki.fi/source/nescom.html)</li>
  <li>Micro Mages (https://morphcatgames.itch.io/micromages)</li>
  <li>Nes Dev Wiki (https://wiki.nesdev.com/w/index.php/Nesdev_Wiki)</li>
  <li>Computer Archeology - The Legend of Zelda (https://www.computerarcheology.com/NES/Zelda/)</li>
  <li>6502 Instruction Set (https://www.masswerk.at/6502/6502_instruction_set.html)</li>
  <li>An introduction to 6502 math: addiction, subtraction and more (https://retro64.altervista.org/blog/an-introduction-to-6502-math-addiction-subtraction-and-more/)</li>
  <li>Explain Half Adder and Full Adder with Truth Table (https://www.elprocus.com/half-adder-and-full-adder/)</li>
  <li>Build a multiplying machine using NAND logic gates (https://codegolf.stackexchange.com/questions/12261/build-a-multiplying-machine-using-nand-logic-gates)</li>
  <li>Tool Assisted Game Movies (https://tasvideos.org/)</li>
  <li>RETRO INSECTIVORES: FINDING AND ELIMINATING BUGS IN NES DEVELOPMENT (https://megacatstudios.com/blogs/press/retro-insectivores-finding-and-eliminating-bugs-in-nes-development)</li>
  <li>FCEUX (https://sourceforge.net/projects/fceultra/)</li>
  <li>Zelda Screen Transitions are Undefined Behaviour (https://gridbugs.org/zelda-screen-transitions-are-undefined-behaviour/)</li>
  <li>NES Emulator Debugging (https://gridbugs.org/nes-emulator-debugging/)</li>
  <li>Two's Complement Multiplication (https://pages.cs.wisc.edu/~david/courses/cs354/beyond354/int.mult.html)</li>
  <li>NES Hello World (https://www.embed.com/nes/hello-world.html)</li>
  <li>DF Direct: CRT Displays - Was LCD A Big Mistake For Gaming? (https://www.youtube.com/watch?v=tvRyVZWuvQ4)</li>
  <li>
    <p>DF Direct! Modern Games Look Amazing On CRT Monitors... Yes, Better than LCD! (https://www.youtube.com/watch?v=V8BVTHxc4LM)</p>
  </li>
  <li>
    <p>Meu fork do emulador de NES em Go (https://github.com/akitaonrails/nes)</p>
  </li>
  <li>Meu c√≥digo do decodificador de c√≥digo de Game Genie (https://github.com/akitaonrails/gamegenie)</li>
</ul>
<p>Assinem estes canais:</p>
<ul>
  <li>Retro Game Mechanics Explained (https://www.youtube.com/channel/UCwRqWnW5ZkVaP_lZF7caZ-g)</li>
  <li>One Lone Coder (https://www.youtube.com/channel/UC-yuWVUplUJZvieEligKBkA)</li>
</ul>
<p></p>