---
title: "[Akitando] #87 Turing Complete, Emuladores e o Chip ARM M1"
date: "2020-11-27T23:00:00.000Z"
tags: ["m1", "arm", "x86", "emulador", "turing complete", "akitando"]
years: "2020"
---

<p><iframe width="560" height="315" src="https://www.youtube.com/embed/kz3649U2sJY" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</p>
<h2>DESCRI√á√ÉO</h2>
<p>Continuando o assunto sobre m√°quinas de Turing hoje resolvi pegar parte do material que eu cortei do epis√≥dio anterior e aproveitar o lan√ßamento do chip Apple M1 pra dar uma introdu√ß√£o ao assunto de emuladores usando aspectos das diferen√ßas de arquitetura RISC/CISC e como ARM e x86 se comparam.</p>
<p>√çndice:</p>
<ul>
  <li>00:00 - Introdu√ß√£o</li>
  <li>01:10 - Turing Complete</li>
  <li>09:37 - Doom roda em QUALQUER lugar :-)</li>
  <li>11:58 - Apple M1 / ARM x x86</li>
  <li>21:40 - Pirataria</li>
</ul>
<p>ERRATA:</p>
<p>No teste de gravidez, eu n√£o prestei aten√ß√£o e deixei passar que na verdade o @foone teve que trocar alguns componentes ent√£o o teste de gravidez n√£o foi usado 100% como veio de f√°brica e portanto N√ÉO, ele n√£o √© um computador universal tamb√©m ü§∑‚Äç‚ôÇÔ∏è de qualquer forma fica o conceito, de que poderia ser, se rodasse Doom ;-) https://twitter.com/renatomefi/status/1332694946575486978?s=20</p>
<p>Links:</p>
<ul>
  <li>Tom Scott: Are There Problems That Computers Can't Solve? (https://www.youtube.com/watch?v=eqvBaj8UYz4)</li>
  <li>Foone: Doom Pregnancy Test (https://twitter.com/Foone/status/1302820468819288066?s=20)</li>
  <li>Matthew Monis: MacBook Pro 13 Review - This M1 is Insane! (https://www.youtube.com/watch?v=BUBYO591Fo8)</li>
  <li>The Untold Story Of The Invention Of The Game Cartridge (https://www.fastcompany.com/3040889/the-untold-story-of-the-invention-of-the-game-cartridge)</li>
</ul>
<p></p>
<p></p>
<h2>TRANSCRIPT</h2>
<p>Ol√° pessoal, Fabio Akita</p>
<p>Fiquei contente que voc√™s gostaram do epis√≥dio que contei um pouco mais sobre a m√°quina de Turing e a arquitetura de Von Neumann. Aquele epis√≥dio tinha ficado grande e eu tive que cortar um trecho enorme pra n√£o perder a linha de racioc√≠nio do que eu queria contar. O trecho era t√£o grande na real, que era praticamente outro epis√≥dio.</p>
<p>Pois √©, no processo de escrever os textos e um dos motivos de porque eu n√£o gosto de fazer live, √© que eu fa√ßo muita tangente e a√≠ o assunto fica mais complicado do que devia. Mesmo cortando eu ainda fa√ßo tangente. Ainda estou praticando cortar coisas, mas vira e mexe acontece de eu escrever 30 p√°ginas e cortar 10 fora, como √© o caso do material de hoje.</p>
<p>Ent√£o a primeira metade do video de hoje vai ser tipo a edi√ß√£o estendida director‚Äôs cut continuando o video anterior, mas a segunda metade vou come√ßar a falar sobre emuladores e at√© dar uma palhinha do que eu acho dos novos chips Apple M1 no contexto de emula√ß√£o e arquitetura. Mas isso vai ser introdu√ß√£o tamb√©m pro pr√≥ximo epis√≥dio onde vou cair mais no meu lado geek e falar de videogames.</p>
<p>(...)</p>
<p>Eu nasci no fim dos anos 70. A revolu√ß√£o dos micro-computadores nasceu praticamente junto comigo. Por exemplo, a Atari foi fundada em 1972, a Microsoft em 75, a Apple em 76. No mesmo ano que eu nasci tamb√©m nascia o computador PET, o antecessor da linha Commodore que sairia em 82. O padr√£o MSX nasceu em 83. O Sinclair ZX Spectrum nasceu em 82 e no Brasil ele foi clonado pela Microdigital e virou o venerado TK 90X, que eu queria ter quando crian√ßa mas n√£o pude.</p>
<p>No caso do TK 90X ele usava processador Zilog Z80, o mesmo tamb√©m usado no Sega Mastersystem que fez muito sucesso no Brasil, fabricado pela Tectoy e que existe at√© hoje. Outros modelos de micros como o Apple II ou Commodore 64 ou mesmo o Atari 2600 usavam o MOS 6502 ou sua evolu√ß√£o, o 65C02, que eu introduzi no epis√≥dio do Guia mais Hardcore de Introdu√ß√£o √† Computa√ß√£o.</p>
<p>Esse mesmo processador equipava o Nintendinho original de 8-bits. E mesmo o Super Nintendo usa o processador da fam√≠lia do 65816 que √© baseado na arquitetura e instru√ß√µes do 6502, meio como um Intel Core i5 de hoje √© uma evolu√ß√£o dos Pentium de antigamente e ainda s√£o compat√≠veis. Recomendo que assistam meu epis√≥dio tamb√©m de Aprendendo sobre Computadores com Super Mario pra entender um pouco de como as instru√ß√µes do 6502 funcionam na pr√°tica.</p>
<p>Essa conversa toda foi s√≥ pra voltar no conceito de m√°quinas Turing Universais ou UTMs. Pra recapitular, uma m√°quina de Turing, a abstra√ß√£o, √© basicamente uma m√°quina com um leitor que consegue ler um bit de cada vez de uma fita infinita, consegue mover essa fita pra esquerda ou pra direita, e al√©m de ler consegue mudar o valor de um bit de cada vez. Mesma coisa o console de um Nintendinho, onde √© poss√≠vel representar tudo que comp√µe o console com um n√∫mero descritivo, porque ele √© uma m√°quina de Turing.</p>
<p>Um cartucho √© um conjunto de chips de ROM. Dentro dessa ROM t√° gravado o programa do jogo e os dados como os sprites, imagens e √°udio que comp√µem o jogo. Mas √© basicamente tudo uma sequ√™ncia de bits. Poder√≠amos escrever os bits todos numa fita. E de fato, antigamente a gente gravava programas e jogos em fitas cassete. Quem √© dos anos 80 deve se lembrar. Era lento pra cacete, mas disk drives ainda eram muito mais caros. Mesmo um disco que tem num HD mec√¢nico ou um CD-ROM √© uma fita de discos em c√≠rculo na m√≠dia.</p>
<p>O cartucho √© como se fosse a tal fita na m√°quina de Turing. Mais do que isso, sem pensar que existem todos esses elementos separados, do ponto de vista da fita ou sequ√™ncia de bits, s√£o zeros e uns um atr√°s do outro. Se n√£o ficou claro, vamos pegar um trecho de assembly que eu mostrei no epis√≥dio do guia de introdu√ß√£o √† computa√ß√£o, instru√ß√µes do 6502. L√° pelo minuto 49 do v√≠deo eu mostro uma sequ√™ncia de instru√ß√µes, lda ff, sta 60 02. Vamos considerar que o programa s√£o s√≥ essas duas linhas. Em hexadecimal isso viraria a9 ff 8d 02 60. Em bin√°rio isso viraria esse numeroz√£o aqui do lado. Se eu jogar na calculadora, e convertermos pra decimal, essas duas linhas de c√≥digo podem ser representados pelo n√∫mero trezentos e sessenta e cinco mil e tra la la que voc√™ pode ver aqui do lado. Entendeu? O programa √â esse n√∫mero.</p>
<p>1010 1001 11111111 1000 1101 0000 0010 1100000
  365068452192</p>
<p>Zeros e uns um atr√°s do outro √© basicamente um numeroz√£o, em bin√°rio. No caso do cartucho do Super Mario √© um numeroz√£o de mais de trezentos e vinte mil d√≠gitos bin√°rios ou bits, pra ser mais exato, porque s√£o 40 kilobytes vezes um mil e vinte e quatro pra termos em bytes e vezes oito pra termos quantos bits, j√° que 8 bits √© 1 byte. Todo programa, n√£o importa o comprimento, √© um numeroz√£o. Todo programa que voc√™ j√° escreveu ou vai escrever pode ser representado por um √∫nico n√∫mero gigante.</p>
<p>N√£o s√≥ o cartucho por ser representado por um n√∫mero, mas o funcionamento do nintendinho inteiro tamb√©m pode ser representado por um numeroz√£o. Uma m√°quina universal de Turing pode pegar o tal n√∫mero descritivo de uma m√°quina de Turing, como o tal numeroz√£o que representa o Nintendinho inteiro e simular. E o resultado dessa simula√ß√£o vai ser exatamente a mesma da m√°quina de Turing correspondente, o console de verdade. Ent√£o, uma caracter√≠stica importante de uma UTM √© sua capacidade de "simular" qualquer outra m√°quina de Turing.</p>
<p>Resumindo. Uma m√°quina de Turing ou m√°quina de computar √© um modelo abstrato capaz de ter um n√∫mero finito de configura√ß√µes ou estados. Ele √© alimentado com uma fita infinita de bits. A cada momento a m√°quina t√° escaneando somente um s√≠mbolo dessa fita de cada vez, e √© autom√°tica porque a cada momento o estado da m√°quina √© determinado pelo s√≠mbolo, ou bit que ele t√° lendo naquele instante. A grosso modo, pense numa m√°quina de Turing como uma fun√ß√£o ou m√©todo de qualquer linguagem de programa√ß√£o moderna.</p>
<p>O tal n√∫mero descritivo representa o corpo dessa fun√ß√£o, o bin√°rio do programa. Esse n√∫mero descritivo ou programa manipula n√∫meros comput√°veis, que na pr√°tica √© quase todo n√∫mero que voc√™ consegue pensar. E usa o que Turing chamou de fun√ß√µes comput√°veis. De curiosidade, ao contr√°rio dos n√∫meros, nem toda fun√ß√£o √© comput√°vel e existe muito mais fun√ß√µes n√£o-comput√°veis do que comput√°veis na real. Portanto uma m√°quina de Turing N√£o consegue computar qualquer coisa. Existem fun√ß√µes que ela n√£o tem capacidade de resolver.</p>
<p>Isso √© um conceito importante porque a intui√ß√£o popular √© que dado tempo suficiente pra evolu√ß√£o de chips e processadores, qualquer problema deveria ser poss√≠vel de resolver com um computador. Por√©m vale saber que existem problemas que um computador de Turing nunca vai resolver. Um exemplo disso √© o Halt Problem. E como √© muita tangente pra hoje, recomendo assistir a explica√ß√£o do Tom Scott, que √© outro canal que eu sigo faz anos. Apenas lembre disso: existem problemas que s√£o imposs√≠veis de resolver com um computador. E n√£o, um computador qu√¢ntico ainda √© uma m√°quina universal de Turing. Daqui algumas d√©cadas tem a possibilidade de ser ridiculamente mais r√°pido que hoje, sem d√∫vida, mas n√£o vai ter mais capacidades nem vai ser capaz de resolver problemas que j√° n√£o se resolve hoje.</p>
<p>De qualquer forma, uma Universal Turing Machine √© uma m√°quina que pode pegar o n√∫mero descritivo de alguma m√°quina de Turing e simular ela perfeitamente. Ent√£o, pra resolver problemas de computa√ß√£o, voc√™ pode escolher uma m√°quina de Turing adequada pra um problema espec√≠fico, j√° que cada m√°quina s√≥ consegue executar uma tarefa. Lembrem-se que antes disso uma m√°quina mec√¢nica era constru√≠da pra resolver s√≥ um tipo de problema. Agora voc√™ pode pegar uma m√°quina Universal, carregar o n√∫mero descritivo ou programa, que √© o tal numeroz√£o que expliquei antes, e simular diversas m√°quinas de Turing. Esse √© o conceito moderno de programa√ß√£o e computadores derivado dos papers de Alan Turing.</p>
<p>Na pr√°tica, computadores reais n√£o s√£o m√°quinas de Turing nem m√°quinas Universais, pelo simples fato que elas tem limites e a defini√ß√£o matem√°tica tem o ideal de mem√≥ria infinita. Mas, pra todos os efeitos e prop√≥sitos, a revolu√ß√£o de Alan Turing foi conseguir definir a id√©ia e conceitos de uma m√°quina de uso geral, em vez de uma m√°quina especializada como calculadoras por exemplo. Uma m√°quina de Turing seria o que chamamos de ‚Äúprograma‚Äù, o tal n√∫mero descritivo seria a implementa√ß√£o desse programa, uma m√°quina Universal √© o computador propriamente dito que consegue rodar diversos programas diferentes.</p>
<p>Algu√©m me perguntou uma vez se uma calculadora ou um √°baco n√£o poderiam ser computadores j√° que ‚Äúcomputam‚Äù n√∫meros. E √© uma pergunta v√°lida. Tecnicamente uma calculadora ‚Äúe‚Äù um computador, intuitivamente, s√£o m√°quinas de calcular. E quando eu falo calculadora n√£o estou falando de coisas como a TI-83 que todo engenheiro que se preze conhece e usa. Uma TI-83 √© definitivamente um computador inteiro, que carrega programas de calcular e plotar gr√°ficos e por isso consegue at√© rodar Doom nele. Estou falando daquelas calculadoras velhas que se tinha nas mesas antigamente.</p>
<p>Na minha defini√ß√£o informal e n√£o-rigorosa, eu costumo pensar num computador como uma m√°quina que consegue simular qualquer outro computador, mesmo que bem mais lento. Performance n√£o define um computador, suas capacidades sim. E uma linguagem Turing Complete, pra mim, √© uma linguagem que consegue programar a simula√ß√£o de outro computador. Se uma determinada m√°quina consegue rodar um emulador, pra mim √© uma m√°quina universal. E se a linguagem de programa√ß√£o √© capaz de escrever um emulador, pra mim ela √© Turing Complete. √â uma defini√ß√£o parcial, mas eu gosto dela porque √© bem pr√°tica. N√£o consegue escrever um emulador, essa linguagem n√£o √© Turing Complete. N√£o consegue rodar um emulador, ent√£o n√£o √© um computador.</p>
<p>Recentemente um usu√°rio que eu sigo no Twitter faz tempo, o @foone, ganhou o notici√°rio porque ele fez Doom rodar num teste de gravidez! Pois √©, a miniaturiza√ß√£o chegou num tal ponto que dentro de um m√≠sero teste de farm√°cia, daqueles que tem uma telinha LCD bem podrona, tem um CPU turing complete, capaz de minimamente executar um jogo ao ponto dele aparecer na tela e rodar. Lento, feio, mas roda. P√°ra pra pensar numa coisa, todo teste de gravidez mais moderno √© um computador inteiro, com um programa feito pra rodar s√≥ uma vez e depois voc√™ jogar no lixo! Isso tudo dito, n√£o, √°baco n√£o √© um computador, a calculadora antiga de mesa n√£o √© um computador, mas um teste de gravidez como esse definitivamente √© um computador.</p>
<p>Toda vez que algu√©m fala coisas como "nossa, conseguiram rodar Doom numa TI-83 ou numa c√¢mera fotogr√°fica" l√≥gico, eu acho impressionante que algu√©m se deu a esse trabalho, mas eu n√£o acho surpreendente porque mesmo um computador fraco √© capaz de simular outro computador, s√≥ vai ser super lento. Mesma coisa quando algu√©m se impressiona quando v√™ uma distribui√ß√£o Linux ou mesmo Windows 95 rodando no Chrome ou Firefox, emulado via Javascript. N√£o me surpreende, mas certamente impressiona, especialmente se voc√™ for iniciante.</p>
<p>Eu entendo a sensa√ß√£o. Eu me sentia da mesma forma nos anos 90, quando eu tinha um PC no n√≠vel de um 486 ou Pentium, que sequer tinha 32 MEGAbytes de RAM, e de repente eu tava conseguindo emular um nintendinho, que n√£o fazia 10 anos s√≥ era poss√≠vel jogar com um console de verdade. Ou a primeira vez que eu instalei o sistema operacional OS/2 que vinha com um emulador de MS-DOS e era poss√≠vel at√© iniciar Windows 3.1 e rodar lado a lado dentro do OS/2. De qualquer forma, esses conceitos explodiam minha mente nos anos 90 e eu entendo que todo iniciante que v√™ isso pela primeira vez, mesmo hoje, deve ficar impressionado.</p>
<p>Agora, falando especificamente de emuladores. Um emulador simula um chip de outro computador via software. Quando um emulador carrega o jogo de um cartucho, o jogo em si n√£o tem id√©ia que t√° rodando num emulador. Pra todos os efeitos e prop√≥sitos, se o jogo tivesse consci√™ncia, ele n√£o teria d√∫vidas que t√° rodando no console de verdade. No m√°ximo ia estranhar, ‚Äúnossa, t√° mais r√°pido esse hardware hoje‚Äù. Esse √© o Matrix de verdade e eu falei um pouco disso no meu epis√≥dio sobre virtualiza√ß√£o, d√™em uma olhada.</p>
<p>Em particular sobre as discuss√µes de ARM versus x86 que t√° na moda agora, isso √© um daqueles eventos que s√≥ acontece um a cada vinte anos. Eu usava Macs em 2006 quando aconteceu a transi√ß√£o de PowerPC pra Intel. N√£o vou entrar em detalhes dessas hist√≥rias porque nesse momento todo canal de tech no YouTube j√° tem v√≠deos a respeito e seria s√≥ ser redundante. Mas √© relevante notar que em 2006 a Apple saiu de uma arquitetura RISC, de instru√ß√µes reduzidas, pra Intel que tem instru√ß√µes complexas. Agora ela t√° fazendo o oposto, saindo de instru√ß√µes complexas e indo pra arquitetura ARM, que √© um RISC, de instru√ß√µes reduzidas.</p>
<p>Pra n√≥s programadores, uma coisa interessante √© a camada Rosetta 2 que tem nos Mac OS a partir do Big Sur. Ele √© um emulador pra conseguir executar bin√°rios legados de x86, convertendo as instru√ß√µes pra ARM. Assim ele consegue rodar programas que n√£o foram recompilados e atualizados pro novo chip M1. Todo reviewer t√° com a cabe√ßa explodindo porque o M1 j√° √© mais r√°pido que modelos de notebooks PC compar√°veis em pre√ßo aos novos Macbook Air ou Macbook Pro 13 polegadas.</p>
<p>Mais do que isso, todo mundo achava que rodar um Photoshop ou Premiere sendo emulado pelo Rosetta seria provavelmente lento. E eles t√£o abismados como a performance n√£o s√≥ t√° aceit√°vel, mas t√° realmente r√°pido, sem engasgos nem nada. Bem diferente de quando pulamos de PowerPC pra Intel em 2006. S√©rio, eu lembro de usar o primeiro Rosetta nos Macbook brancos Intel e rodar qualquer coisa pelo Rosetta era super lento. Dava desgosto de usar. Mas nos M1 de agora, ao que tudo indica, vai rodar quase que igual √† velocidade de quando rodava no Macbook Intel.</p>
<p>Eu fiquei pensando sobre isso e vale lembrar um dos motivos poss√≠veis. Todo mundo t√° cansado de ouvir que a diferen√ßa de chips x86 e ARM √© que um tem instru√ß√µes mais complexas e o outro tem instru√ß√µes mais simples. Pense por um segundo no que isso significa. A cada clock o processador executa uma ou mais instru√ß√µes. Quanto mais instru√ß√µes for poss√≠vel executar por clock, maior a velocidade e menor o consumo de energia. O problema de instru√ß√µes de complexidade variada √© que √© dif√≠cil de adivinhar quantas instru√ß√µes d√° pra rodar a cada clock. Pra ser mais exato, uma instru√ß√£o x86 pode ser de um at√© 15 bytes de comprimento.</p>
<p>Por causa disso um processador Intel costuma executar algo em torno de quatro instru√ß√µes por clock. Isso √© horr√≠vel, porque faz de conta que chegamos numa parte do programa que tem 10 instru√ß√µes simples de um ou 2 bytes um atr√°s do outro. Talvez o processador pudesse rodar oito, dez ou mais instru√ß√µes dessas no mesmo clock. Mas como nem sempre d√° pra saber se cabe ou n√£o, ele roda s√≥ quatro. E fazendo isso ele t√° desperdi√ßando clock, desperdi√ßando energia. E sem mudar a arquitetura de instru√ß√µes, o pipeline sempre vai ser curto e isso √© inerente a ser um x86.</p>
<p>Agora, processadores ARM tem instru√ß√µes ou de 16 ou de 32 bits, ou seja, de 2 ou 4 bytes. E s√≥. E eles n√£o se misturam. Ou voc√™ t√° executando instru√ß√µes de 32-bits ou de 16-bits. Pra mudar entre um ou outro voc√™ manda uma instru√ß√£o pra mudar o mode. Isso significa que voc√™ sempre sabe exatamente o tamanho das instru√ß√µes e com isso pode configurar um pipeline mais longo por clock. Em particular, o chip M1 da Apple consegue executar oito instru√ß√µes por clock. S√≥ em profundidade desse pipeline, um chip M1 de 2Ghz tem potencial de ser duas vezes mais veloz e eficiente do que um chip Intel equivalente de 2Ghz. Mais do que isso, um chip M1 de 2Ghz pode ser competitivo com um chip Intel de 3 ou at√© 4Ghz, por isso voc√™ tanto ganho de bateria e menos calor sendo dissipado.</p>
<p>Mas n√£o √© s√≥ isso. Considere o aspecto de emula√ß√£o. Pra um chip ARM emular Intel √© relativamente mais f√°cil do que Intel emular ARM. Por que? Porque como ARM tem instru√ß√µes simples, ou seja, mais b√°sicas, ela consegue emular facilmente qualquer instru√ß√£o mais complexa de Intel. Por exemplo. Pra facilitar a explica√ß√£o imagina se fossem processadores gr√°ficos. Digamos que em ARM existam fun√ß√µes como desenhar uma linha, desenhar um c√≠rculo, desenhar um tri√¢ngulo.</p>
<p>Por√©m, em Intel existem fun√ß√µes mais complexas como, desenhar um bot√£o, desenhar uma janela. Entenderam o que significa quando se fala em diferen√ßa de complexidade? Um s√≥ desenha linhas o outro numa √∫nica instru√ß√£o j√° desenha um bot√£o inteiro. Com instru√ß√µes nesse ARM hipot√©tico, como desenhar linha, eu consigo desenhar os bot√µes ou janelas. S√≥ vai dar mais trabalho porque eu preciso desenhar linha a linha. Se eu fosse um programador de assembly que precisa usar s√≥ essas instru√ß√µes, seria um parto fazer isso. Mas como hoje escrevemos tudo em C ou outras linguagens, n√£o faz diferen√ßa. Quem vai ter mais trabalho vai ser o compilador e n√£o o programador. Agora, se eu s√≥ tenho instru√ß√µes complexas, como desenhar o bot√£o inteiro, como que eu desenho s√≥ uma linha? F√°cil, eu fa√ßo um bot√£o com 1 pixel de comprimento. S√≥ que agora eu t√¥ gastando o tempo de processamento de desenhar um bot√£o inteiro pra fazer uma simples linha, portanto vai ser mais lento.</p>
<p>Pra piorar a situa√ß√£o, pra rodar instru√ß√µes de x86, voc√™ precisa fazer o equivalente a passar argumentos pra uma fun√ß√£o, como num javascript por exemplo. No caso, os argumentos voc√™ preenche em registradores e depois chama a instru√ß√£o, que seria o equivalente de uma fun√ß√£o. Ou seja, existe um n√∫mero limitado de argumentos que uma instru√ß√£o pode receber, porque existem poucos registradores, que funcionam como vari√°veis globais numa linguagem como Javascript ou PHP. Pois bem, processadores x86 como Intel de 32-bits possui s√≥ 8 registradores de uso geral. Os processadores x86 de 64-bits que a maioria de n√≥s usa hoje tem 16 registradores de uso geral.</p>
<p>Adivinha quantos registradores tem um processador ARM de 32-bits? Dezesseis! E quantos tem o ARMv8 de 64-bits? Trinta e dois registradores. O dobro dos equivalentes x86. Ou seja, fodeu, pra um Intel emular uma instru√ß√£o ARM que tem o dobro de registradores, ele vai ser obrigado a fazer v√°rios truques pra lidar com argumentos que n√£o cabem em todos os registradores que ele tem, e, de novo, a performance vai ser necessariamente mais baixa. No lado oposto, um chip Apple M1 que √© um ARM de 64-bits, ele consegue facilmente emular qualquer instru√ß√£o de x86 64 bits, porque tem registradores sobrando. Ent√£o a programa√ß√£o n√£o precisa de truques, √© super direto.</p>
<p>No frigir dos ovos? √â uma ordem de grandeza mais simples e mais perform√°tico pra um processador ARM emular bin√°rios de x86 do que o oposto. O Rosetta de de 2006 era lento, porque ele tava justamente na situa√ß√£o oposta: precisava fazer os antigos processadores Intel dos novos Mac emular bin√°rios legados de PowerPC que √© uma arquitetura RISC como ARM, era o caso de ter que usar uma fun√ß√£o complexa que desenha um bot√£o e desperdi√ßar o processamento pra emular uma linha.</p>
<p>√â um dos motivos de porque √© mais dif√≠cil ter emuladores de processadores RISC rodando bem em cima de um processador Intel. Por exemplo, at√© hoje n√£o √© perform√°tico emular os antigos PowerPC pra rodar Mac antigo. Da mesma forma √© lento emular chips de smartphone, como os da Qualcomm que tem na maioria dos celulares Android que usamos. J√° o inverso √© mais r√°pido. Por isso eu fiquei um pouco decepcionado com o processador SQ1 que a Microsoft criou em parceria com a Qualcomm pra equipar os Surface Pro X.</p>
<p>O SQ1 √© um Apple M1 piorzinho. Tamb√©m √© um chip ARM e t√° rodando Windows 10 compilado pra ARM, como o Big Sur no caso do Mac. E pra rodar programas legados de x86, ele tamb√©m roda um emulador. At√© hoje t√° limitado a rodar bin√°rios de 32-bits e mesmo assim roda muito lento. T√° pra sair o suporte a emular bin√°rios de 64-bits, e a expectativa √© que seja um pouco melhor, mas mesmo assim ainda atr√°s da Apple. Talvez voc√™ nem tenha ouvido falar do Surface Pro X, mas n√£o √© de hoje que a Microsoft vem tentando usar chips ARM tamb√©m. A Apple n√£o foi a primeira, mas pra variar, foi a que entregou mais bem feito.</p>
<p>O fato de emular x86 em cima de ARM n√£o ser t√£o dif√≠cil e n√£o representar uma perda t√£o significativa de performance √© importante, porque com Windows, MacOS e Linux ganhando cada vez mais otimiza√ß√µes pra ARM, significa que a hegemonia da Intel t√° com os dias contados. Por causa dos smartphones a tecnologia ARM evoluiu bastante e em ambiente m√≥vel, a Intel simplesmente n√£o tem como competir. E agora esses processadores t√£o pulando pra notebooks e desktop, e j√° t√£o bons. E com emuladores ningu√©m vai ficar preso em Intel por causa de aplicativos legados. E se esse caminho der certo, em breve esses chips ARM v√£o invadir em massa o ambiente de servidores. Ali√°s, o maior supercomputador do mundo j√° usa ARM. E isso poderia representar o √∫ltimo prego no caix√£o da Intel. Ela vai precisar se mexer r√°pido pra evitar isso.</p>
<p>Eu vou falar um pouco mais sobre ARM no pr√≥ximo epis√≥dio, mas de qualquer forma a comunidade de desenvolvimento de emuladores √© grande. Eu sempre fico impressionado porque na maior parte s√£o volunt√°rios trabalhando s√≥ pelo prazer de ver as coisas funcionando mesmo, j√° que n√£o se pode ganhar muito dinheiro em cima de jogos que ainda tem licen√ßas e copyrights, especialmente se mexer em consoles da Nintendo. Nunca mexa com a Nintendo, √© processo garantido e muita divers√£o pra se livrar. A √∫nica exce√ß√£o √© se voc√™ vive na China, da√≠ voc√™ t√° seguro.</p>
<p>N√£o d√° pra falar de emuladores e n√£o tocar no assunto de pirataria. √â um assunto controverso, ser a favor ou contra direitos autorais e eu vou dizer que sou neutro nessa discuss√£o. N√£o tenho uma solu√ß√£o completa nem pra um lado, nem pro outro. Ent√£o n√£o vou tentar argumentar hoje. Mas sim, como todo mundo, eu j√° pirateei muito quando era moleque. Eu teria tido muito mais dificuldade pra come√ßar a ganhar dinheiro se n√£o fosse pela pirataria naquela √©poca, ent√£o tem esse ponto mesmo. Hoje em dia n√£o tenho esse problema, ent√£o n√£o tenho motivos pra piratear e pago tudo que eu uso, acho justo.</p>
<p>Mesmo assim, existem software antigos especialmente de lugares como Jap√£o por exemplo, que mesmo eu querendo comprar, n√£o existe pra vender, e nesse caso a pirataria tem a fun√ß√£o de preservar software do passado. E isso √© outro fator importante. Ent√£o, se voc√™ √© a favor ou contra, n√£o sou eu que vou te julgar. Isso tudo dito, assim como todo YouTuber que fala do assunto, eu n√£o vou dizer onde voc√™ encontra jogos pirata, mas qualquer um que saiba usar Google e sabe diferenciar de um malware, vai achar o que procura sem muito trabalho.</p>
<p>E por hoje √© isso a√≠! J√° divaguei bastante e vai ter mais nerdice no pr√≥ximo epis√≥dio. Eu sei que o assunto do Apple M1 t√° na cabe√ßa do povo, mas n√£o pretendo fazer um video s√≥ sobre isso porque j√° tem bastante, mas de vez em quando vou salpicando algumas curiosidades como fiz hoje e vou fazer no pr√≥ximo. Se ficaram com d√∫vidas n√£o deixem de mandar nos coment√°rios, se curtiram o video mandei um joinha e compartilhem o video com seus amigos, assinem o canal e n√£o deixem de clicar no sininho pra n√£o perder os pr√≥ximos videos. A gente se v√™, at√© mais!</p>
<p></p>