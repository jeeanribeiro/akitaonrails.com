---
title: "[Akitando] #91 - Qual a REAL diferen√ßa entre Arquivos Bin√°rio e Texto?? ü§î"
date: "2021-01-20T13:00:00.000Z"
tags: ["unicode", "elf", "execut√°vel", "shell", "zsh", "bash", "akitando"]
years: "2021"
---

<p><iframe width="560" height="315" src="https://www.youtube.com/embed/oSCVb4Ts-G4" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</p>
<h2>DESCRI√á√ÉO</h2>
<p>Um arquivo texto √â um bin√°rio! üò≤</p>
<p>E como um sistema operacional diferencia entre os dois? Porque ele sabe executar um bin√°rio compilado de C, sabe executar um script de Python, mas tamb√©m sabe dar erro se tentamos executar um texto qualquer?</p>
<p>Como isso funciona de verdade por tr√°s dos panos?</p>
<p>Hoje √© dia de escovar bit, e entendermos o que √© ASCII, o que √© ELF e muito mais!</p>
<p>ERRATA:
  - em 05:29 eu falo "porque 10 em decimal √© A" mas eu quis dizer "10 em HEXAdecimal √© A"
  - em 13:53 eu falo que depois de 69 √© 70, mas t√° errado, em hexa depois de 0x69 √© 0x6A, depois 0x6B e assim por diante at√© 0x6F e s√≥ depois seria 0x70</p>
<p>√çNDICE:</p>
<ul>
  <li>00:00 - Intro</li>
  <li>01:14 - Hello World</li>
  <li>04:30 - arquivos texto</li>
  <li>04:59 - arquivos bin√°rios</li>
  <li>06:13 - como um computador boota?</li>
  <li>08:44 - fontes num Nintendinho</li>
  <li>13:29 - ASCII</li>
  <li>17:24 - seguran√ßa: homografia</li>
  <li>19:21 - bin√°rios execut√°veis (ELF)</li>
  <li>25:44 - bin√°rios JPEG</li>
  <li>27:20 - Shells (REPL)</li>
  <li>30:10 - Encerramento</li>
</ul>
<p>LINKS:</p>
<ul>
  <li>Techquickie: The Magic Behind RAM (https://www.youtube.com/watch?v=UKTc9toqgU0)</li>
  <li>Cyrillic (Unicode block) (https://en.wikipedia.org/wiki/Cyrillic_(Unicode_block))</li>
  <li>IDN homograph attack (https://en.wikipedia.org/wiki/IDN_homograph_attack)</li>
  <li>Memory Prices 1957+ (https://jcmit.net/memoryprice.htm)</li>
  <li>Introduction to the ELF Format Part II : Understanding Program Headers (Introduction to the ELF Format Part II : Understanding Program Headers (k3170makan.com))</li>
  <li>Characters, Symbols and the Unicode Miracle - Computerphile (https://www.youtube.com/watch?v=MijmeoH9LT4)</li>
  <li>The 8-Bit Guy - Commodore History (https://www.youtube.com/watch?v=eP9y_7it3ZM&amp;list=PLfABUWdDse7Y6LLPlfsHKcvBCgqaudzVY)</li>
</ul>
<p></p>
<p></p>
<h2>SCRIPT</h2>
<p>Ol√° pessoal, Fabio Akita</p>
<p>Dois videos atr√°s comecei a falar sobre seguran√ßa, mas pra continuar eu preciso come√ßar a complementar o assunto de introdu√ß√£o a computadores com um pouco mais de escova√ß√£o de bits. Se voc√™ assistiu todos os meus v√≠deos pelo menos j√° sabe um pouco de como um computador funciona. Como voc√™ pode carregar um programa via uma ROM por exemplo, como ele vai instru√ß√£o a instru√ß√£o, preenche registradores com resultados, depois voc√™ pode endere√ßar coisas na RAM e assim por diante.</p>
<p>Nos epis√≥dios que falei da m√°quina universal de Turing e a arquitetura de Von Neumann, voc√™ j√° sabe que uma caracter√≠stica importante √© o fato de programas e dados compartilharem o mesmo espa√ßo numa fita e como o computador vai lendo um bit de cada vez dessa fita, seja lendo ou escrevendo nela. Todo iniciante sabe que computadores lidam com bits e bytes. Mesmo assim muitos tem dificuldade de entender o que de fato isso significa. Hoje vou falar um pouco sobre formatos de arquivos, mais especificamente sobre qual a rela√ß√£o de arquivos bin√°rios ou textos planos, e no final espero que voc√™s tenham uma no√ß√£o melhor de como as coisas funcionam por baixo dos panos. Hoje vamos literalmente escovar bits.</p>
<p>(...)</p>
<p>Vamos come√ßar com uma coisa muito simples, o famoso Hello World, mas escrito em C, que √© esse codigozinho idiota aqui do lado. Em C a gente declara depend√™ncia ao arquivo stdio.h ou standard i/o ponto header, porque √© um arquivo de cabe√ßalho. Todo programa em C inicia nessa fun√ß√£o <code>main</code> e dentro temos a chamada da fun√ß√£o <code>printf</code> que s√≥ existe porque inclu√≠mos o stdio.h antes. Passamos a string <code>Hello World</code> e finalmente retornamos 0 que indica pro sistema operacional que o programa terminou com sucesso. E √© s√≥ isso, depois desse ponto o programa termina e sai.</p>
<p>Eu escrevi esse c√≥digo usando um editor de textos, no caso o Vim no meu Linux. E salvei num arquivo chamado hello.c. Se voc√™ for total iniciante poderia pensar "ah, isso √© um programa, portanto posso tentar rodar esse programa n√©?" √â uma pergunta v√°lida. E se tentarmos "rodar" esse arquivo? Voc√™ come√ßou a estudar um pouco de Linux, pra executar alguma coisa que t√° no mesmo diret√≥rio pode simplesmente escrever ponto barra pra dizer que n√£o √© pra procurar no PATH e sim no diret√≥rio atual, da√≠ hello ponto c e ... permission denied, fuck.</p>
<p>Mas voc√™ sabe como resolver! Google! E como mostra no primeiro link, claro, precisa dar permiss√£o pra execu√ß√£o nesse arquivo. No Windows basta que alguma coisa termine em ponto exe ou ponto bat que executa, mas no Linux precisa fazer <code>chmod +x hello.c</code> e agora d√° pra tentar de novo e ... what the fuck, v√°rios erros. ‚ÄúEssa porra de C √© dif√≠cil mesmo, melhor voltar pro CSS‚Äù (ba dum).</p>
<p>N√£o, t√¥ zoando. Esses erros n√£o s√£o de C. Quando voc√™ tenta executar um arquivo de texto na realidade ele t√° fazendo o shell executar. Isso √© o mesmo que executar <code>bash</code> e passando <code>hello.c</code> como par√¢metro. Bash ou Zshell ou Fish ou Powershell s√£o interpretadores, que recebem comandos direto que voc√™ digita direto na linha de comando ou via um script, que √© o que o bash t√° achando que √© esse hello ponto c. Os erros que estamos vendo n√£o √© de C e sim de Bash.</p>
<p>J√° j√° volto pra interpretadores, mas falando s√©rio, eu espero que a esta altura voc√™ saiba que C primeiro precisa ser compilado, que em resumo √© transformar esses comandos que eu escrevi num bin√°rio compat√≠vel com o processador por baixo. E pra isso podemos usar clang ou gcc, mas pra ser old school vou usar gcc. Um simples <code>gcc hello.c -o hello</code>. E pronto, agora posso executar ponto barra hello e boom, Hello World, que era o que eu queria.</p>
<p>Se voc√™ j√° √© programador isso deveria ser trivial, mas vamos pensar como iniciantes. Porque isso que eu fiz funciona? No Linux temos comandos como <code>cat</code> que l√™em o conte√∫do de um arquivo e imprime na tela. Se eu der <code>cat hello.c</code> aparece o que eu escrevi. Mas se eu der <code>cat hello</code> vem esse monte de lixo. O que √© esse monte de lixo? Pra entender isso temos que dar um passo pra tr√°s.</p>
<p>Relembrem o computador de Turing. Ele entende uma fita de bits. Toda mem√≥ria, seja RAM ou ROM, todo SSD ou HD ou pen drive ou, no nosso caso, arquivo texto ou arquivo bin√°rio √© s√≥ isso: uma fita de bits. O comando <code>cat</code> que usamos na verdade faz mais do que s√≥ ler um arquivo: ele traduz o conte√∫do de um arquivo. E ele √© burrinho, a √∫nica coisa que ele faz √© tentar converter uma fita de bits em uma representa√ß√£o de texto.</p>
<p>Uma coisa que hoje √© meio padr√£o √© que representamos texto humanamente leg√≠vel usando uma tabelona chamada UNICODE. At√© pouco tempo atr√°s, antes de UNICODE se disseminar, us√°vamos uma tabela menor chamada ASCII. Unicode √© um assunto super cabeludo que tem v√°rios posts e videos j√° explicando por isso n√£o vou detalhar demais, entenda que √© complexo. Se voc√™ acha que entende tudo de Unicode, voc√™ n√£o entende Unicode.</p>
<p>Em vez de usar o comando <code>cat</code> vamos usar o comando <code>xxd</code> que se n√£o me engano j√° mostrei no video de aprendendo sobre computadores com super mario. Se fizermos <code>xxd -b hello.c</code> vamos ver a fita de bits organizado em colunas de 8 bits que √© um byte, 6 bytes de cada vez pra caber na tela. Na esquerda temos a posi√ß√£o desses bytes, contado em hexadecimal, n√£o confundir com decimal. Podemos contar assim: come√ßa na posi√ß√£o zero, da√≠ um, dois, tr√™s, quatro, cinco, da√≠ pula pra pr√≥xima linha come√ßando na posi√ß√£o seis, continua, sete, oito, nove, ‚ÄúA‚Äù, porque dez em hexadecimal √© A, da√≠ onze √© B e pula de linha e continua na linha seguinte na posi√ß√£o C e assim por diante.</p>
<p>Na coluna da direita temos a tradu√ß√£o desses bytes usando a tabela ASCII. Ent√£o vemos o segundo byte por exemplo, zero um um zero um zero zero um que √© a letra "i". Note que temos outro "i" na palavra <code>stdio</code> e esse "i" est√° no segundo byte da linha que come√ßa no endere√ßo "C" que falei antes. Viu? Olha como o primeiro "i" e o segundo "i" √© a mesma sequ√™ncia zero um um zero um zero zero um. A gente traduz os bytes em letras que conseguimos ler, mas o computador s√≥ v√™ isso, uma fita de bits. Por conven√ß√£o quebramos a fita em blocos de 8 bits, que chamamos de bytes. E 1 byte, na tabela ASCII, traduz pra uma letra.</p>
<p>O que √© uma tabela ASCII? Todo computador hoje vem equipado com essa tabela pr√©-instalada. Entenda assim: uma CPU sozinha n√£o faz nada. Voc√™ liga a energia e ela fica s√≥ l√° sentada esperando. Relembre o video do Guia mais hardcore de introdu√ß√£o √† computa√ß√£o. Nele eu mostro como gravamos um programinha num chip de EPROM e a CPU sempre vai procurar alguma coisa num certo endere√ßo de mem√≥ria pra come√ßar a executar. De forma simplificada, num computador moderno esse chip de EPROM √© o que chamamos de ‚Äúfirmware‚Äù ou BIOS. Por iss,o se voc√™ j√° atualizou o firmware sempre vem avisos de n√£o interromper o processo no meio. Porque se falhar a atualiza√ß√£o do firmware, o computador vai ficar sem o programa que inicia tudo.</p>
<p>BIOS √© acr√¥nimo pra sistema b√°sico de entrada e sa√≠da. E firmware √© uma classe espec√≠fica de programas que oferece fun√ß√µes que chamamos de baixo n√≠vel. Por exemplo, seu Windows ou Linux t√° instalado num HD, mas pra saber que o HD existe e como ler bits do HD e depois identificar que tem pentes de RAM e carregar o Linux na RAM, voc√™ precisa de um programa antes. Esse programa √© o firmware, que oferece fun√ß√µes b√°sicas pra se comunicar com dispositivos de entrada e sa√≠da, como a mem√≥ria.</p>
<p>Se voc√™ assiste canais de montagem de PCs como o Linus Tech Tips, vai ver eles sempre se preocupando num tal de POST depois que o computador liga. POST √© acr√¥nimo pra Power On Self Test ou auto-teste depois de ligar. √â a BIOS rodando e identificando corretamente todo o hardware. Depois desse teste √© que ele come√ßa a sequ√™ncia de boot do sistema operacional, procurando numa ordem espec√≠fica tipo pendrive antes do HD por exemplo. E se for HD procurando numa posi√ß√£o espec√≠fica do HD. No caso do formato antigo MBR ou Master Boot Record, s√£o os primeiros 512 bytes da primeira parti√ß√£o do HD.</p>
<p>Enfim, sem dar muita tangente, uma das coisas que a BIOS carrega √© uma tabela de convers√£o de bits pra letras que um ser humano consegue ler. Essa √© a tabela ASCII, por isso logo que voc√™ liga o computador, ele tem a habilidade de escrever textos na tela pra mostrar o boot antes mesmo do sistema operacional iniciar. √â o que ele usa pra montar a tela de configura√ß√£o da BIOS quando voc√™ aperta F12 por exemplo. Se n√£o ficou claro a import√¢ncia disso, lembram do epis√≥dio de video game? Um videogame bem antigo, tipo nintendinho de 8-bits da vida? Ent√£o, essa √© uma √©poca onde chips de mem√≥ria eram bem caros. Um chip de 64 kilobytes podia ser t√£o caro quanto hoje √© um pente de 64 GIGABYTES. Por isso voc√™ n√£o podia desperdi√ßar um byte.</p>
<p>Uma das formas de economizar mem√≥ria √© que a BIOS de um videogame antigo √© t√£o simples que ele sequer sabe converter bytes em letras. Ali√°s, um console de 8-bits eu acho que nem tinha equivalente de BIOS, bootava direto do cartucho. J√° notou que todo jogo antigo tem fontes diferentes? N√£o √© porque o sistema vem com v√°rias fontes, que nem hoje voc√™ tem Arial ou Verdana ou Times pra escolher. As tais "fontes" precisavam vir na ROM do cartucho, de cada jogo. E pra economizar espa√ßo eles s√≥ colocavam as letras e s√≠mbolos que de fato o jogo fosse usar. Se tivesse alguma letra n√£o precisava, ele pulava. Vamos dar um exemplo, vamos abrir a ROM de um jogo antigo como o Super Mario original com o emulador Mesen.</p>
<p>S√≥ um par√™ntese aqui, o Mesen √© um excelente emulador se voc√™ quiser escovar bit de bin√°rio de cartuchos porque ele tem v√°rias ferramentas de debugging, voc√™ pode escrever assembly de 6502 e ele vai converter pro bin√°rio e inserir onde voc√™ quiser, pode colocar pontos de parada, vasculhar valores nos registradores e tudo mais. Vale a pena pra quem quiser fu√ßar mais a fundo. Mas pra agora vamos usar uma ferramenta que mostra o conte√∫do de segmentos de sprites do cartucho de forma visual.</p>
<p>Vamos direto pra regi√£o de mem√≥ria do cartucho que, por conven√ß√£o, se chama CHR ou characters. Olhem aqui as letras desenhadas do jogo, literalmente caracteres. Como eu expliquei no outro video um Nintendo de 8-bits lida com sprites em vez de pixels individuais, que s√£o conjuntos de oito por oito pixels. Por acaso o caracter"1" est√° na posi√ß√£o 1, a "2" est√° na posi√ß√£o 2 e assim por diante. Pense nessa regi√£o de mem√≥ria como hoje seriam as fontes True Type ou Open Type que voc√™ de front-end e CSS t√° cansado de ver. Fontes modernas carregam em alguma regi√£o espec√≠fica da mem√≥ria e ocupam espa√ßo.</p>
<p>O problema √© que pra representar as letras de oito por oito pixels em mem√≥ria, s√≥ de zero a nove e de A a Z s√£o oito vezes oito vezes trinta e seis letras, o que d√° dois mil e trezentos bytes ou mais de 2 kilobytes. A ROM do Super Mario inteiro ocupa 40 kilobytes, ent√£o 5% do cartucho j√° t√° ocupado s√≥ com essas letras. Por isso evita-se fazer letras maiores, op√ß√µes de mai√∫scula e min√∫scula, porque s√≥ de fazer isso ia quase dobrar o espa√ßo usado.</p>
<p>Pra entender a import√¢ncia de economizar espa√ßo, por volta de 1982, 1 megabyte custava mais de 4 mil d√≥lares. S√≥ esses 2 kilobytes representavam pelo menos 7 a 10 d√≥lares! Consegue imaginar isso? Uma moeda de um quarter ou 25 centavos pra cada letra que eu acabei de mostrar. Em 1990, quase 10 anos depois, o mesmo megabyte caiu de 4 mil d√≥lares pra menos de 100 d√≥lares. E √© por isso que s√≥ a partir dos anos 90 come√ßa a ficar vi√°vel fazer coisas que desperdi√ßam mem√≥ria massivamente como interfaces gr√°ficas e fontes variadas pr√©-instaladas. Nos dias de hoje, 1 megabyte √© super insignificante, √© s√≥ uma fra√ß√£o de centavo, de Real.</p>
<p>Quando os microcomputadores come√ßaram a se popularizar, uma coisa que era meio necess√°rio era ter um m√≠nimo de fontes pr√©-instaladas pra podermos digitar alguma coisa e pro computador conseguir nos mostrar mensagens na tela. E com o tempo passamos a adotar a conven√ß√£o da tabela ASCII, pra ser poss√≠vel transferir um arquivo texto de um computador pra outro de outro fabricante. Se cada fabricante usasse tabelas diferentes, o arquivo texto s√≥ ia conseguir ser lido num outro computador do mesmo fabricante.</p>
<p>No caso dos videogames com cartucho como Super Mario que eu mostrei, o c√≥digo 1 representa o s√≠mbolo gr√°fico 1. Pra escrever meu nome, AKITA, eu representaria na mem√≥ria como os c√≥digos hexadecimais 0A, 14, 12, 0D e 0A de novo. Isso ocupa 5 bytes, porque cada n√∫mero em hexadecimal representa 4 bits, dois n√∫meros s√£o 8 bits, portanto 1 byte. Meu sobrenome tem 5 letras, portanto 5 bytes. Em um byte √© poss√≠vel ir de 00 at√© FF que seria 256 op√ß√µes. Mas no nosso caso a tabela termina no c√≥digo 24. Depois da √∫ltima letra, do c√≥digo 25 pra cima ele mapeia pra outros sprites que s√£o os desenhos tipo dos blocos que o Mario quebra, dos sprites que formam personagens como o pr√≥prio Mario ou os Goombas.</p>
<p>Pra ter uma imagem na cabe√ßa, o que hoje eu chamaria de tabela de fontes, de uma Arial ou Times, no cartucho de um nintendo √© essa √°rea de mem√≥ria da ROM chamada CHR e as fontes s√£o todos os sprites do cartucho. √â como se fiz√©ssemos um jogo s√≥ com as letras que aparece no seu teclado, que o povo fazia mesmo, em DOS antigo. Mas num console ou microcomputadores dos anos 80 como os Vic-20, ZX Spectrum, a gente substituia os caracteres de texto pra caracteres ‚Äúgr√°ficos‚Äù. Por isso em teclados de VIC-20 ou Commodore 64 voc√™ at√© j√° tinha uma tabela alternativa de caracteres, e com eles voc√™ podia desenhar na tela sem precisar especificar pixel a pixel toda hora. Pode ser meio complicado de visualizar se voc√™ nunca viu isso, ent√£o recomendo assistir o canal do 8-Bit Guy, em particular sobre os computadores da Commodore.</p>
<p>Voltando ao nosso exemplo do hello.c, vamos abrir o bin√°rio do arquivo texto em formato hexadecimal. √â a mesma coisa. Note que o segundo caracter √© a letra "i" que a gente viu em bin√°rio agora pouco, em hexadecimal √© o c√≥digo 69. Da√≠ na mesma linha temos o "i" da palavra "stdio" que √© a terceira letra da direita pra esquerda e, claro, temos o c√≥digo 69. Na tabela que temos pra representar as letras, o c√≥digo 69 √© "i", ent√£o o c√≥digo 70 vai ser "j", 71 vai ser "k" e assim por diante at√© Z. Por acaso todo PC usa a mesma tabela e o nome dessa tabela √© a tal ASCII.</p>
<p>ASCII √© abrevia√ß√£o pra American Standard Code Information Interchange. Essa convers√£o se iniciou na √©poca dos tel√©grafos, ent√£o √© l√° pelo meio do s√©culo XX. E foi estabelecido um padr√£o de 7-bits pra trocar textos. 7 bits √© suficiente pra armazenar 2 elevado a 7 ou seja 128 caracteres. Contando 10 n√∫meros, mais 26 letras do alfabeto em mai√∫scula, mais 26 letras em min√∫scula, j√° ocupamos metade da tabela. O resto √© ocupado por s√≠mbolos como os aritm√©ticos de adi√ß√£o ou subtra√ß√£o, par√™nteses, colchetes e assim por diante. 7-bits √© suficiente pra maior parte dos textos escritos em ingl√™s e sobra algum espa√ßo ainda pra alguns caracteres acentuados.</p>
<p>Claro, ASCII, sendo um padr√£o americano, funciona bem pra qualquer l√≠ngua pr√≥xima do ingl√™s. Portugu√™s usa uma varia√ß√£o que encaixa coisas como cedilha. Espanhol precisa no ‚ÄúN‚Äù com til e interroga√ß√£o ao contr√°rio. Outros pa√≠ses adotaram tabelas alternativas. Imagina no Jap√£o por exemplo. 128 caracteres n√£o cabe nem uma fra√ß√£o de todos os s√≠mbolos que se precisa como os famigerados Kanjis. Pra comportar mais caracteres precisamos de mais bytes e da√≠ nasceram extens√µes como o padr√£o EUC que √© Extended Unix Code e pro Jap√£o em particular tem o EUC-JP. Pra China tem EUC-CN, pra Cor√©ia tem EUC-KR e assim por diante.</p>
<p>Tecnicamente um EUC-JP √© mais compat√≠vel com ASCII porque em c√≥digos que come√ßam com 0, ou seja de 7-bits, ele corresponde aos mesmos c√≥digos da tabela ASCII e por isso foi usado em coisas como UNIX vers√£o internacional. No Jap√£o surgiram mais de uma tabela. Apesar da EUC-JP ser mais simples pra usar em conjunto com caracteres ASCII n√£o foi a mais usada. A que eu mais vejo √© a Shift-JIS que foi criada, ironicamente, pela ASCII Corporation do Jap√£o e pela Microsoft. Quando se usa caracteres de 2 bytes, o Shift-JIS √© uma dor de cabe√ßa quando mistura caracteres ASCII porque tem ambiguidade do mesmo c√≥digo ser usado pra s√≠mbolos diferentes dependendo de como foi codificado.</p>
<p>O importante √© entender que l√≠nguas como chin√™s, coreano ou japon√™s s√£o formados por ideogramas, e n√£o s√≠labas com consoantes e vogais. Ent√£o precisa haver uma forma de mapear milhares de s√≠mbolos. Com um √∫nico byte podemos mapear n√£o mais que 256 caracteres. Pra manter 1 byte precisam ser usados tabelas diferentes pra mapear o mesmo n√∫mero pra s√≠mbolos diferentes. Voc√™ imagina a dor de cabe√ßa de ficar trocando entre tabelas diferentes. Quando usamos 2 bytes, a√≠ as possibilidades aumentam pra 2 elevado a 16, que d√° mais de 65 mil s√≠mbolos poss√≠veis e a√≠ j√° cabe quase tudo que precisa. Em Unicode temos UTF-8 pra linguagens ocidentais que se aproxima da tabela ASCII e UTF-16 ou UTF-32 pra outras l√≠nguas por exemplo. Quanto mais bytes se usa por caracter, mais espa√ßo √© desperdi√ßado num arquivo de texto.</p>
<p>Agrade√ßa por ser programador num pa√≠s ocidental que pode usar s√≥ ASCII ou UTF-8, porque coisas simples como gravar um arquivo texto √© simples. Em chin√™s ou japon√™s, especialmente se tiver que lidar com tabelas antigas como EUC-CN em vez de s√≥ Unicode, voc√™ ia chorar l√°grimas de sangue. Imagine fazer coisas como algoritmos de procura de palavras, algoritmos de ordena√ß√£o de palavras, algoritmos de encontrar palavras similares. Coisas que mesmo em ingl√™s ainda n√£o √© perfeito como transcrever um √°udio em palavras. √â muito mais complicado.</p>
<p>Aproveitando essa tangente vale falar de problemas de seguran√ßa que apareciam quando voc√™ entende que t√° num mundo que representa letras diferente do padr√£o ASCII. Os s√≠mbolos em pixels que desenha na tela, que num nintendinho chamamos de sprites, no mundo de fontes chamamos de glifos. Agora, a letra mai√∫scula "A" em latim, ou a mesma letra em cir√≠lico, ou a mesma letra em grego, todas t√™m a mesma imagem ou glifo de "A" nosso, mas cada um √© um c√≥digo diferente nas tabelas Unicode. No caso s√£o respectivamente os c√≥digos 41, 410 e 391. Porque isso √© importante? Porque eu poderia registrar um dom√≠nio que j√° existe, digamos example ponto com e trocar o c√≥digo UTF-8 do "a" min√∫sculo ASCII pro ‚Äúa‚Äù min√∫sculo em cir√≠lico. Humanos v√£o enxergar escrito "example" mas s√£o duas palavras diferentes, com c√≥digos diferentes.</p>
<p>N√£o entendeu? Em bin√°rio, via UTF-8 ou ASCII, √© assim que a palavra <code>example</code> √© representado: <code>65 78 61 6d 70 6c 65 0a</code> mas e se trocarmos pelo "–∞" em cir√≠lico, que √© o alfabeto russo? Ele fica diferente e 1 byte mais longo, assim <code>65 78 d0 b0 6d 70 6c 65 0a</code> esse <code>d0b0</code> √© a letra "a" em cir√≠lico. Se abrirmos com o <code>xxd</code>, que tenta representar segundo a tabela ASCII, ele n√£o sabe que letra √©, ent√£o bota pontos no lugar. S√£o dois bytes que n√£o representam nada na tabela ASCII e isso quebra a palavra pra gente.</p>
<p>Mas num navegador que entende Unicode, voc√™ abre no gmail um e-mail com um link que claramente diz facebook ponto com. Mas o "a" n√£o √© o c√≥digo 61 e sim o 430 em cir√≠lico. Mas voc√™ n√£o tem como saber a diferen√ßa s√≥ olhando pro glifo. Esse tipo de ataque era poss√≠vel antigamente mas hoje em dia n√£o mais porque os registras filtram quando voc√™ tenta registrar. Era um tipo de spoofing via registro de dom√≠nios fakes. √â semelhante a um typosquatting que √© quando voc√™ registra dom√≠nios que soam parecido com o original mas com um errinho que pode passar batido se voc√™ l√™ r√°pido, ou t√° acostumado a falar que nem uma crian√ßa, por exemplo <code>santader.com</code> em vez de <code>santaNder.com</code>.</p>
<p>Voltando ao nosso exemplo original do hello world. Aprendemos que nosso arquivo <code>hello.c</code> √© o que chamamos de um arquivo plain text, ou texto plano, que √© um arquivo que cont√©m apenas bin√°rios que mapeiam pra algum caracter numa tabela como ASCII. Mas pra todos os efeitos pr√°ticos, um arquivo texto tamb√©m √© um arquivo bin√°rio. A extens√£o n√£o modifica nada no arquivo, √© s√≥ uma conven√ß√£o. Dentro dele tem uma fita, uma cadeia de bytes onde cada byte, de acordo com a tabela UTF-8 ou ASCII mapeia cada byte pra um glifo, um desenho de uma letra, n√∫mero ou s√≠mbolo qualquer.</p>
<p>Eu estou sendo bem demorado nessa explica√ß√£o porque voc√™s precisam entender desde cedo que o que voc√™ enxerga como ‚Äútexto‚Äù √© apenas uma representa√ß√£o do shell ou do editor de textos, o arquivo que ele abre √© um bin√°rio como qualquer coisa no sistema. Tudo √© bin√°rio. O que popularmente chamamos de ‚Äúbin√°rio‚Äù √© um tipo espec√≠fico de bin√°rio, os execut√°veis. E agora vou mostrar qual a diferen√ßa do arquivo <code>hello.c</code> que √© um bin√°rio pra texto do bin√°rio execut√°vel <code>hello</code> que foi gerado pelo <code>gcc</code> compilando o c√≥digo que escrevemos dentro desse <code>hello.c</code>.</p>
<p>Se usarmos o mesmo comando <code>xxd hello</code> vamos ver um monte de sujeira na tela. Diferente do arquivo texto que n√≥s digitamos, aqui tem s√≥ umas letras e s√≠mbolos jogados. Mas note que l√° no come√ßo, o arquivo come√ßa com um c√≥digo hexadecimal 7f e depois escreve ELF. Isso indica que este √© um bin√°rio formato ELF que significa Executable and Linking Format, um formato padr√£o de execut√°vel que data da era dos UNIX originais.</p>
<p>Quando tentamos executar esse bin√°rio o sistema operacional, no meu caso o Arch Linux, vai identificar esses primeiros bytes e come√ßar a checar se √© um execut√°vel ELF v√°lido. Pra isso vai validar o cabe√ßalho do arquivo, que ocupa um espa√ßo espec√≠fico de bytes no come√ßo do arquivo. Tem um endere√ßo especial pra identifica√ß√£o de cada coisa. Por exemplo, no 5o byte se tiver o valor 1 significa que √© um bin√°rio de 32-bits, se for 2 significa que √© 64-bits e de fato, temos 2, portanto √© 64-bits.</p>
<p>Se voc√™ nunca entendeu o que √© um protocolo bin√°rio, esse cabe√ßalho √© um tipo de protocolo. Ele delimita campos dentro de uma cadeia de bytes. Por exemplo, do byte 0 at√© o byte 4 precisa ter a palavra <code>ELF</code> em ASCII, no byte 5 temos identifica√ß√£o de 32 ou 64-bits, e assim por diante. Cada campo tem um endere√ßo de come√ßo, um endere√ßo de fim e alguns valores espec√≠ficos e arbitr√°rios que se espera encontrar nesse espa√ßo, segundo a defini√ß√£o do protocolo ELF.</p>
<p>√â tudo s√≥ um lingui√ß√£o de bytes, mas se satisfazer esse protocolo, essas regras de posi√ß√£o e valores, vai ser um execut√°vel ELF de Linux por exemplo. Um protocolo de rede √© a mesma coisa, um lingui√ß√£o de bytes que tem certos campos em certas posi√ß√µes. Uma hora ainda vou falar sobre redes, mas isso deve dar uma no√ß√£o pra agora. Lembre-se, √© um computador de Turing, programa e dados est√£o todos misturados na mesma fita de bytes.</p>
<p>Continuando, tem um tanto de lugares vazios pra poder adicionar informa√ß√µes extras se precisar numa futura nova vers√£o de ELF, mas o programa de verdade s√≥ come√ßa a partir do endere√ßo hexadecimal 0x1000. O que tinha antes eram meta-dados, ou dados que descrevem os dados do bin√°rios. E √© isso que queremos dizer com dados e programas serem a mesma coisa. √â tudo uma fita de dados. Aqui voc√™ v√™ que fica mais denso de bytes diferentes.</p>
<p>Mas note o primeiro, hexadecimal f3 depois 0f da√≠ 1e e fa. √© um comando em assembly de Intel x86 64-bits, o comando <code>endbr64</code>. Assim como t√≠nhamos uma tabela de caracters como ASCII, pra saber sobre esse assembly, voc√™ precisa saber outra tabela, a que mapeia hexadecimais com comandos de assembly. Cada arquitetura de processadores tem uma diferente. Mesmo no mundo Intel, temos instru√ß√µes diferentes entre 32-bits e 64-bits, a maioria √© compat√≠vel mas em 64-bits obviamente temos mais funcionalidades diferentes. Tudo em computadores √© sempre mapear bytes pra alguma coisa. Por isso quanto antes voc√™ se acostumar a conviver com hexadecimais, melhor.</p>
<p>Diferente de um arquivo texto onde os bytes s√£o traduzidos da tabela UTF-8 pra imprimir os glifos na tela pra gente poder ler, quando o Linux detecta que √© um execut√°vel ELF, ele valida os metadados do cabe√ßalho e a partir do endere√ßo 1000 come√ßa a mandar as instru√ß√µes pro processador. Pra ficar menos complicado de enxergar, em vez do comando <code>xxd</code> podemos usar outra ferramenta que vai traduzir o hexadecimal pros mneum√¥nicos de assembly, no caso o <code>objdump</code>.</p>
<p>Ele j√° pula o cabe√ßalho todo e vai direto pro endere√ßo 1000 e veja os mesmos f3 0f 1e fa que √© comando endbr64 que falei. Da√≠ come√ßa uma sequ√™ncia de inicia√ß√£o que vai executar essas instru√ß√µes <code>sub</code> de substrair, <code>mov</code> de mover e assim por diante. Mas e um execut√°vel de Windows? Se a gente copiar o execut√°vel do Mesen que eu tava usando agora pra dentro do Linux podemos ver o conte√∫do bin√°rio dele com o mesmo <code>xxd</code>.</p>
<p>Olha como √© diferente, primeiro ele n√£o come√ßa com <code>ELF</code> e sim com <code>MZ</code>. O cabe√ßalho √© totalmente diferente. A gente n√£o precisa tamb√©m ficar tentando ler byte a byte do cabe√ßalho pra saber o que s√£o as coisas. Todos as distribui√ß√µes de Linux tem um comando chamado <code>file</code> que justamente sabe reconhecer diversos tipos de cabe√ßalhos de bin√°rios e identificar de uma forma que humanos consegue entender. Por exemplo, se fizermos <code>file hello</code> veja que ele identifica corretamente como um execut√°vel ELF Intel de 64-bits. Se fizermos <code>file Mesen.exe</code> vemos que identifica como um PE32 ou Portable Executable de 32-bits Intel, em particular √© um assembly de .NET Mono.</p>
<p>Todo arquivo no sistema √© um lingui√ß√£o de bytes. Se forem bytes que existem na tabela UTF-8, provavelmente √© um arquivo texto, como o c√≥digo do <code>hello.c</code>. Quando compilamos com o <code>gcc</code> ele gera outro lingui√ß√£o de bytes, mas vai ter o formato ELF que √© execut√°vel de Linux. Da√≠ quando mandamos executar <code>hello</code> ele vai identificar o cabe√ßalho, validar, descer at√© o endere√ßo 1000 do arquivo e achar as instru√ß√µes assembly pra come√ßar a mandar pro processador. Por outro lado temos diversos outros tipos de lingui√ß√£o de dados, por exemplo, uma imagem JPEG que todo mundo conhece, como as fotos que seu smartphone tira.</p>
<p>Vamos abrir um arquivo com <code>xxd</code> pra ver como √©. Novamente, temos um lingui√ß√£o de bytes, mas em particular esse come√ßa com ff d8. Se formos at√© o fim do arquivo temos ff d9. Todo arquivo JPEG come√ßa e termina do mesmo jeito. Indo at√© o fim, esse ff d9 indica quando o arquivo acaba porque em nenhum lugar ele indica o tamanho total. Mas voltando pro come√ßo, a partir do byte 6 vemos que o <code>xxd</code> reconheceu quatro c√≥digos que mapeiam na tabela ASCII pra JFIF que significa JPEG File Interchange Format. Os bytes ff d8 j√° identificam o arquivo como JPEG mas tem esse JFIF porque tamb√©m existe o EXIF que √© Exchangeable Image File Format que √© um formato similar feito por fabricantes de c√¢meras digitais de antigamente.</p>
<p>Essa √© uma das formas que o sistema operacional reconhece que tipo de arquivo estamos lidando. Se for um bin√°rio que tem um lingui√ß√£o de bytes que encaixa no formato ELF, √© um execut√°vel e, se tiver permiss√£o de execu√ß√£o, tenta executar. Se for um bin√°rio com cabe√ßalho de JFIF √© uma imagem JPEG e um programa de ver imagens vai saber os endere√ßos dentro que precisa pra localizar a imagem propriamente dita. E assim por diante pra todo tipo de arquivo. Zips, video, √°udio.</p>
<p>E no caso de arquivos texto, eles s√£o bin√°rios tamb√©m, cujos cabe√ßalhos n√£o s√£o nenhum dos anteriores e podemos tentar mapear byte a byte pra uma tabela como UTF-8. Caso venha s√≥ um texto quebrado com lixo no meio de letras, que n√£o parece com palavra nenhuma, pode ser um encoding diferente, digamos um texto antigo em japon√™s e, nesse caso, se usar a tabela EUC-JP ou Shift-JIS, podemos encontrar palavras em japon√™s, se o programa que estivermos usando souber usar os glifos do alfabeto japon√™s.</p>
<p>Por √∫ltimo, vale falar do problema inicial. Por que n√£o podemos executar o c√≥digo do arquivo <code>hello.c</code> diretamente sem compilar? Primeiro, ele n√£o √© um bin√°rio ELF nem PE ent√£o n√£o cont√™m instru√ß√µes em assembly pra passar pro processador. Mas por que eu consigo executar direto um arquivo de Python, ou Perl, ou Javascript? Isso porque normalmente ele tem duas coisas. No caso espec√≠fico de Linux, vai ter permiss√£o de execu√ß√£o e segundo, na primeira linha vai conter o caminho no sistema pra um interpretador. Chamamos essa linha de shebang ou simplesmente bang. Se abrir um script de Python, voc√™ vai ver que costuma ter essa primeira linha neles.</p>
<p>Se s√≥ tiver permiss√£o de execu√ß√£o mas n√£o tiver shebang, quem vai tentar executar esse arquivo texto, que agora chamamos de shebang, vai ser o shell onde estamos neste instante. Por exemplo, quando eu abro um Terminal do Arch Linux, configurei pra iniciar o Zshell. Se for um Linux normal ou um Terminal no MacOS, sem configurar nada extra, normalmente vai abrir o famoso Bash. Um Windows vem por padr√£o com o Powershell. Existem v√°rios interpretadores de terminal. Eu explico mais no epis√≥dio sobre WSL 2.</p>
<p>Essa linha de comando √© um ambiente de programa√ß√£o. Podemos escrever programinhas. Ent√£o toda vez que voc√™ cai na tal linha de comando, pode imediatamente escrever c√≥digo sem abrir um editor de textos separado. Em microcomputadores antigos dos anos 80 como um MSX ou Apple II ou Commodore 64, o equivalente shell deles era o Basic. E como toda linguagem de programa√ß√£o ele tem uma sintaxe, fun√ß√µes e comandos espec√≠ficos dessa linguagem que, por acaso, n√£o tem nada a ver com a linguagem C. E por isso quando voc√™ tenta executar o <code>hello.c</code> ele vai dizer que tem erros de sintaxe. Claro, n√£o √© a mesma linguagem. Voc√™ mandou essa shell que, digamos, √© brasileiro, tentar ler um texto em chin√™s e a√≠ ele buga mesmo.</p>
<p>A mesma coisa acontece quando voc√™ abre o console do Python, ou um console qualquer de Javascript ou Ruby. Da√≠ vai ser um outro shell rodando em cima do shell original, Bash ou Zshell. Todo mundo de Ruby por exemplo conhece o IRB que abre uma linha de comando onde podemos executar direto comandos de Ruby. IRB √© um acr√¥nimo pra Interactive Ruby Shell. Est√° no nome, ele √© um shell. Mais especificamente um REPL ou Read-Eval-Print Loop, ou traduzindo, um Loop de leitura, execu√ß√£o e impress√£o. Ou seja, um programa que fica em loop infinito sempre esperando ler um comando, da√≠ tentar executar, que √© um evaluate ou <code>eval</code> desse comando, e imprimir o resultado na tela. √â um shell.</p>
<p>Confunde um pouco pra quem est√° come√ßando porque √© dif√≠cil distinguir o que s√£o fun√ß√µes nativas dos shells como Zshell ou Bash e o que s√£o bin√°rios execut√°veis que parecem fun√ß√µes. Por exemplo, todo mundo conhece o comando <code>echo</code> que imprime o string que passamos pra ele na tela. Mas fora no Zshell, ele √© um execut√°vel que fica em barra usr barra echo. Os shells tem bem poucas fun√ß√µes nativas, por exemplo <code>cd</code> pra mudar de diret√≥rio ou <code>alias</code> pra criar atalhos.</p>
<p>E por hoje vamos ficar por aqui. Eu acho que uma das coisas que mais facilita a vida de um programador √© o quanto antes ele se tornar √≠ntimo do computador que usa. Muitos passam anos s√≥ trabalhando com linguagens de alto n√≠vel e evitam ao m√°ximo lidar com bin√°rios, hexadecimais, pacotes, streams, porque parece uma coisa bizarra, tipo tentar ler chin√™s. S√≥ que isso limita suas capacidades como programador. E limita bastante. Ser um programador n√£o √© receber pe√ßas de Lego e sair juntando que nem um idiota, em breve √© bom voc√™ mesmo saber fazer suas pr√≥prias pe√ßas de Lego. Se curtiram o video deixem um joinha e compartilhem o video com seus amigos, n√£o deixem de assinar o canal e clicar no sininho pra n√£o perder os pr√≥ximos. A gente se v√™, at√© mais!</p>
<p></p>